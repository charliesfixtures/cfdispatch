<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CF Dispatch</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Syne:wght@400;500;600;700;800&family=DM+Sans:wght@300;400;500;600&family=DM+Mono:wght@400;500&family=Inter+Tight:wght@300;400;500;600;700&display=swap');

:root {
  --accent:  #f0c93a;
  --success: #6ecf96;
  --danger:  #e07a5f;
  --info:    #5b9cf6;
  --mon: #f0c93a; --tue: #5b9cf6; --wed: #6ecf96; --thu: #e07a5f; --fri: #b87fff;
  --glass: rgba(200,195,185,0.5);
  --glass-border: rgba(255,255,255,0.35);
  --blur: blur(40px) saturate(1.8) brightness(1.1);
  --card-bg: rgba(180,175,165,0.35);
  --card-border: rgba(255,255,255,0.25);
  --text: rgba(0,0,0,0.85);
  --text2: rgba(0,0,0,0.58);
  --text3: rgba(0,0,0,0.35);
  --radius: 12px;
  --shadow: 0 8px 32px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.5);
}

* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow: hidden; }

body {
  font-family: 'Inter Tight', sans-serif;
  background: #e8e4dc;
  color: rgba(0,0,0,0.85);
  width: 100%;
  height: 100%;
  position: fixed;
  overflow: hidden;
}

/* ‚îÄ‚îÄ HEADER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.header { display: none; }

.logo {
  font-family: 'Syne', sans-serif;
  font-weight: 800;
  font-size: 16px;
  color: var(--accent);
  letter-spacing: -0.02em;
  white-space: nowrap;
}

.logo span { color: rgba(0,0,0,0.35); font-weight: 400; }

.header-sep { width: 1px; height: 24px; background: rgba(0,0,0,0.1); }

.sync-info { display: none; }

.sync-dot {
  width: 6px; height: 6px;
  border-radius: 50%;
  background: var(--success);
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

.header-actions {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 8px;
}

.btn-icon {
  width: 34px; height: 34px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.35);
  background: rgba(200,195,185,0.5);
  backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  -webkit-backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  color: rgba(0,0,0,0.45);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 15px;
  transition: all 0.15s;
  box-shadow: 0 2px 12px rgba(0,0,0,0.06), inset 0 1px 0 rgba(255,255,255,0.4);
}

.btn-icon:hover { background: rgba(0,0,0,0.06); color: rgba(0,0,0,0.7); border-color: rgba(255,255,255,0.45); }

.btn-primary {
  height: 32px;
  padding: 0 14px;
  border-radius: 8px;
  border: none;
  background: var(--accent);
  color: #000;
  font-family: 'Inter Tight', sans-serif;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
}

.btn-primary:hover { background: #f5d660; }

/* ‚îÄ‚îÄ DRIVER STATUS BAR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.driver-bar { display: none; }

.driver-chip {
  display: flex;
  align-items: center;
  gap: 7px;
  padding: 4px 10px 4px 4px;
  border-radius: 20px;
  background: rgba(0,0,0,0.04);
  border: 1px solid rgba(0,0,0,0.08);
}

.driver-chip.unavailable {
  opacity: 0.6;
  border-color: var(--danger);
  background: rgba(224,122,95,0.06);
}

.driver-avatar {
  width: 26px; height: 26px;
  border-radius: 50%;
  object-fit: cover;
  border: 2px solid rgba(0,0,0,0.1);
}

.driver-chip.unavailable .driver-avatar { filter: grayscale(60%); }

.driver-name {
  font-size: 12px;
  font-weight: 500;
  color: rgba(0,0,0,0.7);
}

.driver-status {
  font-size: 10px;
  font-family: 'Inter Tight', sans-serif;
  color: rgba(0,0,0,0.42);
}

.driver-chip.unavailable .driver-status { color: var(--danger); }

.driver-bar-sep { font-size: 10px; color: rgba(0,0,0,0.1); }

/* ‚îÄ‚îÄ LAYOUT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.workspace {
  position: fixed;
  inset: 0;
  overflow: hidden;
  z-index: 1;
}

/* ‚îÄ‚îÄ LEFT PANEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.panel-left {
  position: fixed;
  top: 16px;
  left: 16px;
  width: 270px;
  z-index: 400;
  display: flex;
  flex-direction: column;
  gap: 6px;
  max-height: calc(100vh - 32px);
  pointer-events: all;
}

.panel-header {
  background: rgba(200,195,185,0.5);
  backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  -webkit-backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  border: 1px solid rgba(255,255,255,0.35);
  border-radius: var(--radius);
  padding: 12px 14px 10px;
  flex-shrink: 0;
  box-shadow: 0 8px 32px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.5);
}

.panel-title {
  font-family: 'Inter Tight', sans-serif;
  font-size: 11px;
  font-weight: 700;
  color: rgba(0,0,0,0.45);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}

.badge {
  background: rgba(0,0,0,0.04);
  border: 1px solid rgba(0,0,0,0.08);
  color: rgba(0,0,0,0.45);
  font-size: 10px;
  font-family: 'Inter Tight', sans-serif;
  padding: 2px 7px;
  border-radius: 10px;
}

.badge.has-items { background: rgba(0,0,0,0.06); border-color: rgba(0,0,0,0.1); color: rgba(0,0,0,0.55); }

.panel-search {
  position: relative;
  margin-top: 6px;
}

.panel-search input {
  width: 100%;
  background: rgba(0,0,0,0.04);
  border: 1px solid rgba(0,0,0,0.08);
  border-radius: 8px;
  padding: 7px 10px 7px 28px;
  color: rgba(0,0,0,0.7);
  font-family: 'Inter Tight', sans-serif;
  font-size: 12px;
  outline: none;
  transition: border-color 0.2s;
}

.panel-search input:focus { border-color: rgba(0,0,0,0.2); }
.panel-search input::placeholder { color: rgba(0,0,0,0.25); }

.panel-search::before {
  content: 'üîç';
  position: absolute;
  left: 9px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 11px;
  pointer-events: none;
}

.cards-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
  overflow-y: auto;
  max-height: calc(100vh - 140px);
  padding: 6px 0;
  background: transparent;
}

.cards-list::-webkit-scrollbar { width: 4px; }
.cards-list::-webkit-scrollbar-track { background: transparent; }
.cards-list::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.14); border-radius: 2px; }

/* Queue card */
.queue-card {
  background: rgba(200,195,185,0.5);
  backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  -webkit-backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  border: 1px solid rgba(255,255,255,0.35);
  border-radius: var(--radius);
  padding: 16px 18px;
  cursor: grab;
  transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
  position: relative;
  box-shadow: 0 8px 32px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.5);
}

.queue-card:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 16px rgba(0,0,0,0.1);
}

.queue-card:active {
  cursor: grabbing;
}

.queue-card.selected {
  border-color: rgba(240,201,58,0.5);
  background: rgba(240,201,58,0.08);
}

.queue-card.expanded {
  background: rgba(170,165,155,0.45);
}

/* Warning border removed ‚Äî amber algo strip text is sufficient cue */
.queue-card.has-warning { }
.queue-card.has-warning-soft { }

.queue-card.dragging { opacity: 0.4; transform: rotate(1deg); }

.qc-title { font-size: 14px; font-weight: 700; color: rgba(0,0,0,0.55); margin-bottom: 6px; line-height: 1.25; padding-right: 38px; font-family: 'Inter Tight', sans-serif; }

.qc-flags { display: flex; flex-wrap: wrap; gap: 4px; margin: 2px 0 0 0; align-items: center; }

.qc-tag {
  font-size: 9px;
  font-family: 'Inter Tight', sans-serif;
  padding: 2px 6px;
  border-radius: 3px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.04em;
  color: rgba(0,0,0,0.45);
  background: rgba(0,0,0,0.05);
  border: none;
}

/* Algo recommendation strip */
.algo-strip {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 9px;
  margin: 8px 0 0 0;
  background: rgba(0,0,0,0.03);
  border-radius: 6px;
  font-size: 11px;
  font-family: 'Inter Tight', sans-serif;
  color: rgba(0,0,0,0.45);
  font-weight: 500;
}
.algo-strip .algo-icon { font-size: 10px; opacity: 0.6; }
.algo-strip .algo-label { color: rgba(0,0,0,0.55); font-weight: 600; }
.algo-strip .algo-detail { color: rgba(0,0,0,0.38); }
.algo-strip .algo-dist { margin-left: auto; color: rgba(0,0,0,0.3); font-size: 10px; }

/* Requester avatar */
.qc-avatar {
  width: 28px; height: 28px; border-radius: 50%; object-fit: cover;
  position: absolute; top: 12px; right: 14px;
  border: 1.5px solid rgba(0,0,0,0.1); opacity: 0.85; z-index: 5;
}
.qc-avatar-initials {
  width: 28px; height: 28px; border-radius: 50%;
  background: rgba(0,0,0,0.08);
  position: absolute; top: 12px; right: 14px;
  display: flex; align-items: center; justify-content: center;
  font-size: 10px; font-weight: 600; color: rgba(0,0,0,0.4);
  font-family: 'Inter Tight', sans-serif;
}

/* Expanded card content */
.qc-expanded-content {
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid rgba(0,0,0,0.06);
  font-family: 'Inter Tight', sans-serif;
}
.qc-expanded-row {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11.5px;
  color: rgba(0,0,0,0.42);
  padding: 3px 0;
  font-family: 'Inter Tight', sans-serif;
}
.qc-expanded-row .exp-icon {
  font-size: 12px;
  width: 18px;
  text-align: center;
  flex-shrink: 0;
}
.qc-expanded-row strong {
  color: rgba(0,0,0,0.52);
  font-weight: 600;
}
.qc-expanded-row em {
  font-style: italic;
}
.qc-expanded-divider {
  height: 1px;
  background: rgba(0,0,0,0.05);
  margin: 6px 0;
}
.qc-expanded-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin-top: 6px;
}
.qc-expanded-tags .exp-tag {
  font-size: 9px;
  padding: 2.5px 7px;
  border-radius: 3px;
  font-weight: 600;
  letter-spacing: 0.3px;
  background: rgba(0,0,0,0.05);
  color: rgba(0,0,0,0.4);
  font-family: 'Inter Tight', sans-serif;
}

.qc-address { display: none; }

.qc-actions { display: none; }

.qc-btn {
  flex: 1;
  padding: 5px 0;
  border-radius: 6px;
  border: 1px solid rgba(0,0,0,0.08);
  background: rgba(0,0,0,0.03);
  color: rgba(0,0,0,0.45);
  font-size: 11px;
  font-family: 'Inter Tight', sans-serif;
  cursor: pointer;
  transition: all 0.15s;
  text-align: center;
}

.qc-btn:hover { background: rgba(0,0,0,0.06); color: rgba(0,0,0,0.7); }
.qc-btn.primary { background: rgba(240,201,58,0.1); border-color: rgba(240,201,58,0.3); color: var(--accent); }
.qc-btn.primary:hover { background: rgba(240,201,58,0.2); }

.fix-btn {
  font-size: 10px;
  padding: 3px 8px;
  border-radius: 5px;
  border: 1px solid rgba(224,122,95,0.3);
  background: rgba(224,122,95,0.08);
  color: var(--danger);
  cursor: pointer;
  text-decoration: none;
  display: inline-block;
  margin-top: 4px;
  transition: all 0.15s;
}

.fix-btn:hover { background: rgba(224,122,95,0.15); }

/* Empty state */
.empty-state {
  text-align: center;
  padding: 32px 20px;
  color: rgba(0,0,0,0.2);
}

.empty-state .icon { font-size: 28px; margin-bottom: 10px; }
.empty-state .title { font-size: 12px; font-weight: 500; color: rgba(0,0,0,0.35); margin-bottom: 6px; }
.empty-state .sub { font-size: 11px; line-height: 1.6; color: rgba(0,0,0,0.25); }

/* ‚îÄ‚îÄ CENTER MAP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.map-container {
  position: fixed;
  inset: 0;
  z-index: 0;
}

#map {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
}

/* Day layer toggles on map */
.map-controls {
  position: fixed;
  top: 16px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: row;
  flex-wrap: nowrap;
  gap: 2px;
  z-index: 500;
  background: rgba(200,195,185,0.5);
  border: 1px solid rgba(255,255,255,0.35);
  border-radius: 28px;
  padding: 4px;
  backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  -webkit-backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  box-shadow: 0 8px 32px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.5);
  pointer-events: all;
}

.day-pill {
  padding: 6px 11px;
  border-radius: 22px;
  font-size: 11px;
  font-family: 'Inter Tight', sans-serif;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  border: 1px solid transparent;
  color: rgba(0,0,0,0.35);
  user-select: none;
  text-align: center;
  line-height: 1.2;
  position: relative;
}

.pill-day { display: block; letter-spacing: 0.04em; font-weight: 600; }
.pill-date { display: block; font-size: 9px; color: rgba(0,0,0,0.2); margin-top: 1px; font-weight: 400; transition: color 0.2s; }

.day-pill:hover { color: rgba(0,0,0,0.6); background: rgba(0,0,0,0.04); border-color: rgba(0,0,0,0.06); }
.day-pill:hover .pill-date { color: rgba(0,0,0,0.3); }
.day-pill.active { color: rgba(0,0,0,0.75); font-weight: 700; }
.day-pill.active:not([style]) { background: var(--accent); border-color: rgba(240,201,58,0.6); box-shadow: 0 2px 12px rgba(240,201,58,0.25), inset 0 1px 0 rgba(255,255,255,0.2); }
.day-pill.active .pill-date { color: rgba(0,0,0,0.5); }

/* ‚îÄ‚îÄ RIGHT PANEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.panel-right {
  position: fixed;
  top: 16px;
  right: 16px;
  width: 290px;
  z-index: 400;
  display: flex;
  flex-direction: column;
  gap: 6px;
  max-height: calc(100vh - 100px);
  pointer-events: all;
}

.day-tabs {
  background: rgba(200,195,185,0.5);
  backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  -webkit-backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  border: 1px solid rgba(255,255,255,0.35);
  border-radius: var(--radius);
  display: flex;
  overflow: hidden;
  flex-shrink: 0;
  box-shadow: 0 8px 32px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.5);
}

.day-tabs::-webkit-scrollbar { display: none; }

.day-tab {
  flex: 1;
  padding: 9px 4px 7px;
  text-align: center;
  cursor: pointer;
  transition: all 0.15s;
  border-bottom: 2px solid transparent;
  font-size: 10px;
  font-family: 'Inter Tight', sans-serif;
  color: rgba(0,0,0,0.3);
  user-select: none;
}

.day-tab:hover { color: rgba(0,0,0,0.55); background: rgba(0,0,0,0.04); }
.day-tab.active { color: var(--accent); border-bottom-color: var(--accent); background: rgba(240,201,58,0.04); }
.day-tab .tab-label { font-weight: 600; letter-spacing: 0.04em; }
.day-tab .tab-count { font-size: 9px; margin-top: 2px; color: rgba(0,0,0,0.2); }
.day-tab.active .tab-count { color: rgba(240,201,58,0.5); }

/* Route day header (replaces day tabs in right panel) */
.route-day-header {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 14px;
  background: rgba(200,195,185,0.5);
  backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  -webkit-backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  border: 1px solid rgba(255,255,255,0.35);
  border-radius: var(--radius);
  box-shadow: 0 8px 32px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.5);
  flex-shrink: 0;
}

.route-day-dot {
  width: 8px; height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
  display: none;
}

.route-day-info { flex: 1; padding-left: 4px; }
.route-day-name { font-size: 16px; font-weight: 600; color: rgba(0,0,0,0.6); font-family: 'Inter Tight', sans-serif; }
.route-day-meta { display: none; }

.route-panel {
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 6px;
  max-height: calc(100vh - 160px);
  padding: 2px 0;
}

.route-panel::-webkit-scrollbar { width: 4px; }
.route-panel::-webkit-scrollbar-track { background: transparent; }
.route-panel::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.14); border-radius: 2px; }

/* Truck section */
.truck-section {
  background: rgba(200,195,185,0.5);
  backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  -webkit-backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  border: 1px solid rgba(255,255,255,0.35);
  border-radius: var(--radius);
  overflow: hidden;
  flex-shrink: 0;
  box-shadow: 0 8px 32px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.5);
}

.truck-header {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 12px;
  border-bottom: 1px solid rgba(0,0,0,0.06);
}

.truck-driver-img {
  width: 24px; height: 24px;
  border-radius: 50%;
  object-fit: cover;
  border: 2px solid rgba(0,0,0,0.1);
}

/* Driver avatar wrap ‚Äî clickable */
.truck-driver-avatar-wrap {
  position: relative;
  cursor: pointer;
  border-radius: 50%;
  transition: all 0.15s;
  flex-shrink: 0;
}

.truck-driver-avatar-wrap:hover { transform: scale(1.08); }
.truck-driver-avatar-wrap:hover .truck-driver-img { border-color: var(--accent); }
.truck-driver-avatar-wrap.unavailable .truck-driver-img { filter: grayscale(50%); border-color: var(--danger); }

.driver-unavail-badge {
  position: absolute;
  bottom: -2px;
  right: -2px;
  width: 12px; height: 12px;
  border-radius: 50%;
  background: var(--danger);
  color: #fff;
  font-size: 8px;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1.5px solid rgba(200,195,185,0.8);
}

/* Driver placeholder ‚Äî empty circle with person icon */
.truck-driver-placeholder {
  width: 28px; height: 28px;
  border-radius: 50%;
  border: 2px dashed rgba(0,0,0,0.15);
  display: flex;
  align-items: center;
  justify-content: center;
  color: rgba(0,0,0,0.2);
  cursor: pointer;
  transition: all 0.2s;
  flex-shrink: 0;
}

.truck-driver-placeholder:hover {
  border-color: var(--accent);
  color: var(--accent);
  background: rgba(240,201,58,0.06);
  transform: scale(1.08);
}

/* Truck section warning state when driver unavailable */
.truck-section.driver-warn { border-color: rgba(224,122,95,0.2); }

/* Driver picker enhancements */
.driver-option.unavailable-option { opacity: 0.5; }
.driver-option.unavailable-option:hover { opacity: 0.7; }
.driver-placeholder-small {
  width: 32px; height: 32px;
  border-radius: 50%;
  border: 1px solid rgba(0,0,0,0.1);
  background: rgba(0,0,0,0.04);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  color: rgba(0,0,0,0.25);
  flex-shrink: 0;
}

.truck-info { flex: 1; }
.truck-name { font-size: 13px; font-weight: 700; color: rgba(0,0,0,0.6); font-family: 'Inter Tight', sans-serif; }
.truck-label { font-size: 10px; color: rgba(0,0,0,0.35); font-family: 'Inter Tight', sans-serif; margin-top: 1px; }

.capacity-bar-wrap {
  display: flex;
  align-items: center;
  gap: 5px;
}

.capacity-dots {
  display: flex;
  gap: 3px;
}

.cap-dot {
  width: 8px; height: 8px;
  border-radius: 2px;
  background: rgba(0,0,0,0.1);
  transition: background 0.2s;
}

.cap-dot.filled { background: var(--success); }
.cap-dot.overflow { background: var(--danger); }

.truck-lock-btn {
  width: 22px; height: 22px;
  border-radius: 5px;
  border: 1px solid rgba(0,0,0,0.1);
  background: transparent;
  color: rgba(0,0,0,0.2);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  transition: all 0.15s;
}

.truck-lock-btn:hover { background: rgba(0,0,0,0.04); color: rgba(0,0,0,0.4); }
.truck-lock-btn.locked { background: rgba(224,122,95,0.1); border-color: rgba(224,122,95,0.3); color: var(--danger); }

.truck-section.truck-locked {
  opacity: 0.55;
  pointer-events: none;
}
.truck-section.truck-locked .truck-header {
  pointer-events: all;
}
.truck-section.truck-locked .truck-lock-btn {
  pointer-events: all;
}
.truck-section.truck-locked .truck-empty {
  color: rgba(180,90,40,0.45);
  font-style: italic;
}

/* Stop items */
.stops-list {
  border-top: 1px solid rgba(0,0,0,0.06);
}

.stop-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  border-bottom: 1px solid rgba(0,0,0,0.04);
  transition: background 0.15s;
  position: relative;
  flex-wrap: wrap;
}

.stop-item:last-child { border-bottom: none; }
.stop-item:hover { background: rgba(0,0,0,0.03); }

.stop-num {
  width: 22px; height: 22px;
  border-radius: 6px;
  background: rgba(0,0,0,0.05);
  border: 1px solid rgba(0,0,0,0.08);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 9px;
  font-family: 'Inter Tight', sans-serif;
  font-weight: 600;
  flex-shrink: 0;
  color: rgba(0,0,0,0.4);
  cursor: grab;
}

.drag-handle {
  cursor: grab;
  letter-spacing: -1px;
}

.drag-handle:active { cursor: grabbing; }

.stop-item[draggable="true"]:hover { cursor: grab; }

.stop-content { flex: 1; min-width: 0; overflow: hidden; }
.stop-name { font-size: 11px; font-weight: 600; color: rgba(0,0,0,0.6); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }
.stop-meta { font-size: 10px; color: rgba(0,0,0,0.35); margin-top: 2px; display: flex; gap: 5px; flex-wrap: wrap; }

.stop-flag {
  font-size: 9px;
  padding: 1px 5px;
  border-radius: 3px;
  font-family: 'Inter Tight', sans-serif;
}

.flag-first { background: rgba(79,142,255,0.15); color: var(--info); }
.flag-wg { background: rgba(126,214,160,0.12); color: var(--success); }
.flag-remove { background: rgba(224,122,95,0.12); color: var(--danger); }

.stop-actions {
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.15s;
  flex-shrink: 0;
}

.stop-item:hover .stop-actions { opacity: 1; }
.stop-item.staged .stop-actions { opacity: 1; }

.stop-btn {
  width: 22px; height: 22px;
  border-radius: 5px;
  border: 1px solid rgba(0,0,0,0.1);
  background: rgba(0,0,0,0.04);
  color: rgba(0,0,0,0.2);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  transition: all 0.15s;
}

.stop-btn:hover { background: rgba(0,0,0,0.1); color: rgba(0,0,0,0.7); }
.stop-btn.remove:hover { background: rgba(224,122,95,0.1); border-color: rgba(224,122,95,0.3); color: var(--danger); }

/* Route endpoints */
.route-endpoint {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 5px 12px;
  background: rgba(0,0,0,0.03);
  font-size: 10px;
  color: rgba(0,0,0,0.3);
  font-family: 'Inter Tight', sans-serif;
}

.endpoint-icon { font-size: 12px; }

/* Empty truck */
.truck-empty {
  padding: 16px;
  text-align: center;
  font-size: 11px;
  color: rgba(0,0,0,0.25);
  font-style: italic;
}

/* Commit button */
.commit-wrap { display: none; }

.commit-btn {
  width: 100%;
  padding: 10px;
  border-radius: 8px;
  border: none;
  background: var(--accent);
  color: #000;
  font-family: 'Inter Tight', sans-serif;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.commit-btn:hover { background: #f5d660; }
.commit-btn:disabled { background: rgba(0,0,0,0.06); color: rgba(0,0,0,0.2); cursor: not-allowed; }

/* ‚îÄ‚îÄ DROP ZONE ‚îÄ‚îÄ */
.truck-section.drop-hover {
  border-color: rgba(240,201,58,0.6);
  background: rgba(240,201,58,0.06);
  box-shadow: 0 0 0 2px rgba(240,201,58,0.2), 0 8px 32px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.5);
}

.truck-section.drop-reject {
  border-color: rgba(224,122,95,0.4);
  background: rgba(224,122,95,0.04);
}

.drop-insert-line {
  height: 2px;
  background: var(--accent);
  margin: 0 12px;
  border-radius: 1px;
  opacity: 0;
  transition: opacity 0.15s;
  box-shadow: 0 0 8px rgba(240,201,58,0.4);
}

.drop-insert-line.visible {
  opacity: 1;
}

/* ‚îÄ‚îÄ STAGED STOP (dragged but not committed) ‚îÄ‚îÄ */
.stop-item.staged {
  border: 1.5px solid color-mix(in srgb, var(--day-color, #f0c93a) 60%, transparent);
  border-radius: 10px;
  margin: 4px 6px;
  padding: 10px 12px;
  background: linear-gradient(135deg, color-mix(in srgb, var(--day-color, #f0c93a) 18%, transparent) 0%, color-mix(in srgb, var(--day-color, #f0c93a) 8%, transparent) 100%);
  box-shadow: 0 2px 12px color-mix(in srgb, var(--day-color, #f0c93a) 12%, transparent), inset 0 1px 0 rgba(255,255,255,0.4);
}

.stop-item.staged .stop-num {
  background: color-mix(in srgb, var(--day-color, #f0c93a) 35%, transparent);
  border-color: color-mix(in srgb, var(--day-color, #f0c93a) 40%, transparent);
  color: rgba(0,0,0,0.65);
  font-weight: 700;
}

.stop-item.staged .stop-name {
  color: rgba(80,55,0,0.85);
  font-weight: 700;
}

.stop-item.staged .stop-meta {
  color: rgba(100,70,0,0.5);
}

/* Per-card commit button ‚Äî gray on golden card */
.stop-commit-btn {
  padding: 4px 10px;
  border-radius: 6px;
  border: 1px solid rgba(0,0,0,0.12);
  background: rgba(0,0,0,0.06);
  color: rgba(0,0,0,0.55);
  font-family: 'Inter Tight', sans-serif;
  font-size: 10px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.15s;
  letter-spacing: 0.02em;
  white-space: nowrap;
}

.stop-commit-btn:hover {
  background: rgba(0,0,0,0.12);
  color: rgba(0,0,0,0.8);
  border-color: rgba(0,0,0,0.2);
  box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

/* Edit/remove buttons on staged ‚Äî also muted */
.stop-item.staged .stop-btn {
  border-color: rgba(160,120,0,0.15);
  color: rgba(120,85,0,0.3);
}
.stop-item.staged .stop-btn:hover {
  background: rgba(160,120,0,0.08);
  color: rgba(100,70,0,0.6);
}

/* Staged timestamp row */
.staged-meta {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 0 0 36px;
  font-size: 9.5px;
  font-family: 'Inter Tight', sans-serif;
  color: rgba(160,120,0,0.4);
  letter-spacing: 0.01em;
  flex-basis: 100%;
}
.staged-meta .staged-by {
  font-weight: 600;
  color: rgba(160,120,0,0.5);
}
.staged-meta .staged-time {
  font-weight: 400;
}

/* Rider tag on queue cards */
.rider-tag {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  font-size: 9px;
  font-weight: 600;
  font-family: 'Inter Tight', sans-serif;
  letter-spacing: 0.04em;
  text-transform: uppercase;
  padding: 2px 7px;
  border-radius: 4px;
  background: rgba(120,100,220,0.1);
  color: rgba(100,80,180,0.7);
  border: 1px solid rgba(120,100,220,0.15);
  cursor: pointer;
  margin-left: auto;
}
.rider-tag:hover {
  background: rgba(120,100,220,0.18);
}

/* Rider toggle button in card */
.rider-toggle {
  font-size: 9px;
  font-family: 'Inter Tight', sans-serif;
  padding: 2px 7px;
  border-radius: 4px;
  border: 1px dashed rgba(0,0,0,0.12);
  background: rgba(0,0,0,0.02);
  color: rgba(0,0,0,0.3);
  cursor: pointer;
  letter-spacing: 0.03em;
  margin-left: auto;
}
.rider-toggle:hover {
  background: rgba(120,100,220,0.08);
  border-color: rgba(120,100,220,0.2);
  color: rgba(100,80,180,0.6);
}

/* Free delivery toggle (inside expanded view) */
.free-toggle {
  font-size: 9px;
  font-family: 'Inter Tight', sans-serif;
  padding: 3px 8px;
  border-radius: 4px;
  border: 1px dashed rgba(0,0,0,0.12);
  background: rgba(0,0,0,0.02);
  color: rgba(0,0,0,0.3);
  cursor: pointer;
  letter-spacing: 0.03em;
  transition: all 0.15s;
}
.free-toggle:hover {
  background: rgba(120,100,220,0.08);
  border-color: rgba(120,100,220,0.2);
  color: rgba(100,80,180,0.6);
}
.free-toggle.active {
  background: rgba(120,100,220,0.12);
  border: 1px solid rgba(120,100,220,0.25);
  color: rgba(100,80,180,0.8);
  font-weight: 600;
}

/* FREE micro-badge inline with card title */
.free-badge {
  font-size: 7px;
  font-family: 'Inter Tight', sans-serif;
  font-weight: 700;
  letter-spacing: 0.05em;
  padding: 1px 4px;
  border-radius: 3px;
  background: rgba(120,100,220,0.12);
  color: rgba(100,80,180,0.7);
  border: 1px solid rgba(120,100,220,0.15);
  text-transform: uppercase;
  display: inline-flex;
  align-items: center;
  flex-shrink: 0;
}

/* ‚îÄ‚îÄ COMMITTED STOP ‚îÄ‚îÄ */
.stop-item.committed {
  border-left: 3px solid var(--success);
  background: rgba(110,207,150,0.04);
}

.stop-item.committed .stop-num {
  background: rgba(110,207,150,0.12);
  border-color: rgba(110,207,150,0.3);
  color: rgba(40,120,70,0.7);
}

/* ‚îÄ‚îÄ DRIVER PICKER ‚îÄ‚îÄ */
.driver-picker {
  position: fixed;
  z-index: 800;
  background: var(--card-bg);
  backdrop-filter: var(--blur);
  -webkit-backdrop-filter: var(--blur);
  border: 1px solid var(--card-border);
  border-radius: var(--radius);
  padding: 8px;
  min-width: 200px;
  box-shadow: var(--shadow);
  animation: fadeIn 0.15s ease;
}

@keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

.driver-picker-title {
  font-size: 10px;
  font-family: 'Inter Tight', sans-serif;
  color: rgba(0,0,0,0.3);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  padding: 4px 6px 8px;
  border-bottom: 1px solid rgba(0,0,0,0.06);
  margin-bottom: 6px;
}

.driver-option {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 10px;
  border-radius: 8px;
  cursor: pointer;
  transition: background 0.15s;
}

.driver-option:hover { background: rgba(0,0,0,0.05); }
.driver-option.selected { background: rgba(240,201,58,0.08); }

.driver-option img {
  width: 32px; height: 32px;
  border-radius: 50%;
  object-fit: cover;
  border: 2px solid rgba(0,0,0,0.1);
  flex-shrink: 0;
}

.driver-option-info { flex: 1; }
.driver-option-name { font-size: 12px; font-weight: 600; color: rgba(0,0,0,0.7); }
.driver-option-status { font-size: 10px; color: rgba(0,0,0,0.4); margin-top: 1px; }
.driver-option-status.away { color: var(--danger); }
.driver-option-status.soon { color: var(--accent); }

/* ‚îÄ‚îÄ MODAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  backdrop-filter: blur(6px);
  z-index: 2000;
  display: none;
  align-items: center;
  justify-content: center;
}

.modal-overlay.open { display: flex; }

.modal {
  background: rgba(220,215,205,0.92);
  backdrop-filter: blur(40px) saturate(1.8) brightness(1.05);
  -webkit-backdrop-filter: blur(40px) saturate(1.8) brightness(1.05);
  border: 1px solid rgba(255,255,255,0.4);
  border-radius: 14px;
  padding: 24px;
  width: 420px;
  max-width: 95vw;
  max-height: 90vh;
  overflow-y: auto;
  animation: modalIn 0.2s ease;
  color: rgba(0,0,0,0.7);
}

@keyframes modalIn {
  from { transform: scale(0.95) translateY(10px); opacity: 0; }
  to { transform: scale(1) translateY(0); opacity: 1; }
}

.modal-title {
  font-family: 'Syne', sans-serif;
  font-size: 16px;
  font-weight: 700;
  margin-bottom: 4px;
}

.modal-sub { font-size: 12px; color: rgba(0,0,0,0.42); margin-bottom: 20px; }

.form-group { margin-bottom: 16px; }
.form-label { font-size: 11px; color: rgba(0,0,0,0.42); margin-bottom: 6px; font-weight: 500; display: block; }

.form-select, .form-input {
  width: 100%;
  background: rgba(0,0,0,0.04);
  border: 1px solid rgba(0,0,0,0.1);
  border-radius: 8px;
  padding: 9px 12px;
  color: rgba(0,0,0,0.7);
  font-family: 'Inter Tight', sans-serif;
  font-size: 13px;
  outline: none;
  transition: border-color 0.2s;
  appearance: none;
}

.form-select:focus, .form-input:focus { border-color: var(--info); }

.modal-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }

.modal-actions {
  display: flex;
  gap: 8px;
  margin-top: 20px;
}

.btn-cancel {
  flex: 1;
  padding: 10px;
  border-radius: 8px;
  border: 1px solid rgba(0,0,0,0.1);
  background: rgba(0,0,0,0.04);
  color: rgba(0,0,0,0.6);
  font-family: 'Inter Tight', sans-serif;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.15s;
}

.btn-cancel:hover { background: rgba(0,0,0,0.06); }

.btn-confirm {
  flex: 2;
  padding: 10px;
  border-radius: 8px;
  border: none;
  background: var(--accent);
  color: #000;
  font-family: 'Inter Tight', sans-serif;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
}

.btn-confirm:hover { background: #f5d660; }

/* First stop section in modal */
.first-stop-section {
  background: rgba(79,142,255,0.06);
  border: 1px solid rgba(79,142,255,0.2);
  border-radius: 8px;
  padding: 10px 12px;
  margin-bottom: 16px;
}

.first-stop-title { font-size: 11px; color: var(--info); font-weight: 600; margin-bottom: 4px; }
.first-stop-desc { font-size: 11px; color: rgba(0,0,0,0.42); }

.first-stop-btns { display: flex; gap: 6px; margin-top: 8px; }
.fs-btn {
  flex: 1;
  padding: 6px;
  border-radius: 6px;
  font-size: 11px;
  font-family: 'Inter Tight', sans-serif;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s;
  border: 1px solid rgba(0,0,0,0.1);
  background: rgba(0,0,0,0.04);
  color: rgba(0,0,0,0.42);
  text-align: center;
}

.fs-btn.selected { background: var(--info); border-color: var(--info); color: #fff; }
.fs-btn.revoke.selected { background: var(--danger); border-color: var(--danger); color: #fff; }

.truck-c-wrap {
  padding: 0 8px 6px;
  flex-shrink: 0;
}

.truck-c-btn {
  width: 100%;
  padding: 8px;
  border-radius: var(--radius);
  border: 1px dashed rgba(0,0,0,0.15);
  background: rgba(200,195,185,0.35);
  backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  -webkit-backdrop-filter: blur(40px) saturate(1.8) brightness(1.1);
  color: rgba(0,0,0,0.3);
  font-family: 'Inter Tight', sans-serif;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.15s;
}

.truck-c-btn:hover { border-color: var(--accent); color: var(--accent); }

/* ‚îÄ‚îÄ BRAND FLOAT ‚îÄ‚îÄ */
.brand-float {
  position: fixed;
  bottom: 20px;
  left: 20px;
  z-index: 400;
  pointer-events: none;
}

.brand-logo {
  height: 30px;
  display: block;
  opacity: 0.5;
  filter: brightness(0.45);
}

.brand-byline {
  font-family: 'Inter Tight', sans-serif;
  font-size: 8.5px;
  color: rgba(0,0,0,0.22);
  letter-spacing: 0.04em;
}

.brand-sync {
  display: flex;
  align-items: center;
  gap: 4px;
}

.brand-sync span {
  font-size: 9px;
  color: rgba(0,0,0,0.18);
  font-family: 'Inter Tight', sans-serif;
  letter-spacing: 0.02em;
}

.brand-sub {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 1px;
  margin-left: 2px;
}

.brand-sep { width: 1px; height: 16px; background: rgba(0,0,0,0.1); }

/* ‚îÄ‚îÄ SUGGESTION BANNER ‚îÄ‚îÄ */
.suggestion-banner {
  position: fixed;
  bottom: 80px;
  left: 50%;
  transform: translateX(-50%) translateY(20px);
  z-index: 600;
  background: rgba(220,215,205,0.88);
  backdrop-filter: blur(40px) saturate(1.8) brightness(1.05);
  -webkit-backdrop-filter: blur(40px) saturate(1.8) brightness(1.05);
  border: 1px solid rgba(240,201,58,0.25);
  border-radius: 14px;
  padding: 14px 18px;
  display: flex;
  align-items: center;
  gap: 16px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.1), 0 0 0 1px rgba(240,201,58,0.15);
  opacity: 0;
  pointer-events: none;
  transition: all 0.3s ease;
  max-width: 520px;
}

.suggestion-banner.visible {
  opacity: 1;
  pointer-events: all;
  transform: translateX(-50%) translateY(0);
}

.suggestion-text { flex: 1; }
.suggestion-label { font-size: 11px; font-family: 'Inter Tight', sans-serif; color: var(--accent); text-transform: uppercase; letter-spacing: 0.06em; margin-bottom: 4px; }
.suggestion-detail { font-size: 13px; font-weight: 600; color: rgba(0,0,0,0.7); }
.suggestion-meta { font-size: 11px; color: rgba(0,0,0,0.38); margin-top: 2px; }
.suggestion-actions { display: flex; gap: 6px; flex-shrink: 0; }
.sug-btn { padding: 6px 12px; border-radius: 7px; font-size: 11px; font-family: 'Inter Tight', sans-serif; font-weight: 600; cursor: pointer; border: 1px solid rgba(0,0,0,0.1); transition: all 0.15s; }
.sug-btn.confirm { background: rgba(240,201,58,0.15); border-color: rgba(240,201,58,0.35); color: var(--accent); }
.sug-btn.confirm:hover { background: rgba(240,201,58,0.25); }
.sug-btn.adjust { background: rgba(0,0,0,0.05); color: rgba(0,0,0,0.55); }
.sug-btn.adjust:hover { background: rgba(0,0,0,0.08); color: rgba(0,0,0,0.7); }
.sug-btn.dismiss { background: transparent; border-color: rgba(0,0,0,0.08); color: rgba(0,0,0,0.3); padding: 6px 8px; }
.sug-btn.dismiss:hover { color: var(--danger); border-color: rgba(224,122,95,0.3); }

/* ‚îÄ‚îÄ ACTION FLOAT ‚îÄ‚îÄ */
.action-float {
  position: fixed;
  top: 16px;
  right: 320px;
  z-index: 600;
  display: flex;
  gap: 6px;
}

/* ‚îÄ‚îÄ TOAST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.toast-container {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 3000;
  display: flex;
  flex-direction: column;
  gap: 8px;
  pointer-events: none;
}

.toast {
  background: rgba(220,215,205,0.92);
  backdrop-filter: blur(40px) saturate(1.8) brightness(1.05);
  -webkit-backdrop-filter: blur(40px) saturate(1.8) brightness(1.05);
  border: 1px solid rgba(255,255,255,0.4);
  border-radius: 10px;
  padding: 10px 14px;
  font-size: 12px;
  color: rgba(0,0,0,0.7);
  max-width: 280px;
  display: flex;
  align-items: center;
  gap: 8px;
  animation: toastIn 0.3s ease;
  pointer-events: all;
  box-shadow: 0 4px 20px rgba(0,0,0,0.2);
}

@keyframes toastIn {
  from { transform: translateX(20px); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}

.toast.success { border-color: rgba(126,214,160,0.3); }
.toast.error { border-color: rgba(224,122,95,0.3); }
.toast.info { border-color: rgba(79,142,255,0.3); }

/* ‚îÄ‚îÄ LEAFLET CUSTOM PINS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.driver-pin {
  position: relative;
  width: 36px;
  height: 36px;
}

.driver-pin img {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  object-fit: cover;
  border: 3px solid #fff;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.driver-pin .stop-badge {
  position: absolute;
  bottom: -2px;
  right: -2px;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--bg);
  border: 2px solid #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 8px;
  font-weight: 700;
  font-family: 'Inter Tight', sans-serif;
  color: #fff;
}

.unscheduled-pin {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: rgba(230,100,80,0.75);
  border: 2.5px solid rgba(255,255,255,0.9);
  box-shadow: 0 0 0 3px rgba(230,100,80,0.25);
  cursor: pointer;
  transition: all 0.2s;
  animation: pulseDot 2s infinite;
}

.unscheduled-pin.selected {
  width: 20px;
  height: 20px;
  background: rgba(230,100,80,0.9);
  border-color: #fff;
  margin: -3px;
  animation: pulseSelected 1s infinite;
  box-shadow: 0 0 0 5px rgba(230,100,80,0.25), 0 0 0 10px rgba(230,100,80,0.1);
}

@keyframes pulseDot {
  0%, 100% { box-shadow: 0 0 0 0 rgba(230,100,80,0.5); }
  50% { box-shadow: 0 0 0 8px rgba(230,100,80,0); }
}

/* ASAP urgency ‚Äî faster pulse, slightly bigger */
.unscheduled-pin.asap {
  width: 18px;
  height: 18px;
  background: rgba(220,60,40,0.8);
  border: 2.5px solid rgba(255,255,255,0.95);
  animation: pulseAsap 1s infinite;
}

@keyframes pulseAsap {
  0%, 100% { box-shadow: 0 0 0 0 rgba(220,60,40,0.6); }
  50% { box-shadow: 0 0 0 10px rgba(220,60,40,0); }
}

@keyframes pulseSelected {
  0%, 100% { box-shadow: 0 0 0 3px rgba(230,100,80,0.5), 0 0 0 6px rgba(230,100,80,0.2); }
  50% { box-shadow: 0 0 0 6px rgba(230,100,80,0.3), 0 0 0 12px rgba(230,100,80,0.1); }
}

.landmark-pin {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Landmark rich hover tooltip */
.landmark-tip {
  background: rgba(235,230,220,0.94) !important;
  backdrop-filter: blur(20px) saturate(1.5) brightness(1.05);
  -webkit-backdrop-filter: blur(20px) saturate(1.5) brightness(1.05);
  border: 1px solid rgba(255,255,255,0.4) !important;
  border-radius: 10px !important;
  box-shadow: 0 4px 20px rgba(0,0,0,0.12) !important;
  padding: 14px 16px !important;
  font-family: 'Inter Tight', sans-serif;
  line-height: 1.55;
}
.landmark-tip::before { border-right-color: rgba(235,230,220,0.94) !important; }
.lm-t { font-size: 14px; font-weight: 700; color: rgba(0,0,0,0.65); margin-bottom: 5px; }
.lm-r { font-size: 12px; color: rgba(0,0,0,0.4); margin: 2px 0; }
.lm-h { font-size: 11px; color: rgba(0,0,0,0.35); margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(0,0,0,0.06); }

/* Route line animation ‚Äî marching dashes show direction of travel */
@keyframes flowDash {
  from { stroke-dashoffset: 0; }
  to { stroke-dashoffset: -24; }
}
.route-line {
  /* Static by default ‚Äî animation applied via .route-animate */
}
.route-line.route-animate {
  animation: flowDash 0.8s linear infinite;
}
.route-line.route-dim {
  opacity: 0.2 !important;
}

/* Map dot hover tooltip (pending + scheduled) */
.dot-tip {
  background: rgba(235,230,220,0.94) !important;
  backdrop-filter: blur(20px) saturate(1.5) brightness(1.05);
  -webkit-backdrop-filter: blur(20px) saturate(1.5) brightness(1.05);
  border: 1px solid rgba(255,255,255,0.4) !important;
  border-radius: 8px !important;
  box-shadow: 0 4px 16px rgba(0,0,0,0.1) !important;
  padding: 10px 12px !important;
  font-family: 'Inter Tight', sans-serif;
  line-height: 1.5;
}
.dot-tip::before { border-right-color: rgba(235,230,220,0.94) !important; }
.dt-name { font-size: 12px; font-weight: 700; color: rgba(0,0,0,0.65); margin-bottom: 2px; }
.dt-owner { font-size: 10.5px; color: rgba(0,0,0,0.4); }
.dt-status { font-size: 10px; margin-top: 3px; padding-top: 3px; border-top: 1px solid rgba(0,0,0,0.06); }
.dt-pending { color: rgba(230,100,80,0.7); font-weight: 600; }
.dt-scheduled { color: rgba(76,155,60,0.8); font-weight: 600; }

.landmark-icon {
  width: 30px;
  height: 30px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  border: 2px solid rgba(255,255,255,0.5);
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

/* ‚îÄ‚îÄ SETTINGS PANEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.settings-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(4px);
  z-index: 2000;
  display: none;
  align-items: center;
  justify-content: center;
}

.settings-overlay.open { display: flex; }

.settings-panel {
  background: rgba(220,215,205,0.92);
  backdrop-filter: blur(40px) saturate(1.8) brightness(1.05);
  -webkit-backdrop-filter: blur(40px) saturate(1.8) brightness(1.05);
  border: 1px solid rgba(255,255,255,0.4);
  border-radius: 14px;
  padding: 28px;
  width: 440px;
  max-width: 95vw;
  max-height: 90vh;
  overflow-y: auto;
}

.settings-title {
  font-family: 'Syne', sans-serif;
  font-size: 18px;
  font-weight: 700;
  margin-bottom: 4px;
}

.settings-sub { font-size: 12px; color: rgba(0,0,0,0.42); margin-bottom: 24px; }

.settings-section { margin-bottom: 20px; }

.settings-section-title {
  font-size: 10px;
  font-family: 'Inter Tight', sans-serif;
  color: rgba(0,0,0,0.42);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 10px;
  padding-bottom: 8px;
  border-bottom: 1px solid rgba(0,0,0,0.08);
}

.connect-btn {
  width: 100%;
  padding: 11px;
  border-radius: 8px;
  border: none;
  background: var(--accent);
  color: #000;
  font-family: 'Inter Tight', sans-serif;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
  margin-top: 4px;
}

.connect-btn:hover { background: #f5d660; }

.connection-status {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 12px;
  border-radius: 8px;
  background: rgba(0,0,0,0.04);
  border: 1px solid rgba(0,0,0,0.08);
  font-size: 12px;
  margin-top: 8px;
}

/* Confirm dialog */
.confirm-dialog {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(4px);
  z-index: 3000;
  display: none;
  align-items: center;
  justify-content: center;
}

.confirm-dialog.open { display: flex; }

.confirm-box {
  background: rgba(220,215,205,0.92);
  backdrop-filter: blur(40px) saturate(1.8) brightness(1.05);
  -webkit-backdrop-filter: blur(40px) saturate(1.8) brightness(1.05);
  border: 1px solid rgba(255,255,255,0.4);
  border-radius: 12px;
  padding: 24px;
  width: 340px;
  max-width: 90vw;
  animation: modalIn 0.2s ease;
}

.confirm-icon { font-size: 28px; margin-bottom: 12px; }
.confirm-title { font-size: 15px; font-weight: 600; margin-bottom: 6px; }
.confirm-msg { font-size: 12px; color: rgba(0,0,0,0.42); line-height: 1.5; margin-bottom: 20px; }

.confirm-actions { display: flex; gap: 8px; }

.confirm-cancel {
  flex: 1;
  padding: 9px;
  border-radius: 8px;
  border: 1px solid rgba(0,0,0,0.1);
  background: rgba(0,0,0,0.04);
  color: rgba(0,0,0,0.6);
  font-family: 'Inter Tight', sans-serif;
  font-size: 13px;
  cursor: pointer;
}

.confirm-ok {
  flex: 1;
  padding: 9px;
  border-radius: 8px;
  border: none;
  background: var(--danger);
  color: #fff;
  font-family: 'Inter Tight', sans-serif;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
}

/* Tooltip popup */
.leaflet-popup-content-wrapper {
  background: rgba(220,215,205,0.92) !important;
  backdrop-filter: blur(40px) saturate(1.8) brightness(1.05) !important;
  -webkit-backdrop-filter: blur(40px) saturate(1.8) brightness(1.05) !important;
  border: 1px solid rgba(255,255,255,0.4) !important;
  border-radius: 12px !important;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3) !important;
  color: rgba(0,0,0,0.7) !important;
}

.leaflet-popup-tip-container { display: none !important; }
.leaflet-popup-close-button { color: rgba(0,0,0,0.3) !important; font-size: 16px !important; top: 8px !important; right: 10px !important; }
.leaflet-popup-close-button:hover { color: rgba(0,0,0,0.7) !important; }
.leaflet-popup-content { margin: 14px 16px !important; font-family: 'Inter Tight', sans-serif !important; min-width: 200px; }

.popup-title { font-size: 13px; font-weight: 700; color: rgba(0,0,0,0.7); margin-bottom: 10px; line-height: 1.3; font-family: 'Syne', sans-serif; }
.popup-divider { height: 1px; background: rgba(0,0,0,0.06); margin: 8px 0; }
.popup-row { font-size: 11px; color: rgba(0,0,0,0.45); margin-bottom: 5px; display: flex; gap: 8px; align-items: flex-start; line-height: 1.4; }
.popup-row strong { color: rgba(0,0,0,0.6); font-weight: 500; }
.popup-row .popup-icon { opacity: 0.6; flex-shrink: 0; }
.popup-tag { display: inline-block; font-size: 9px; font-family: 'Inter Tight', sans-serif; padding: 2px 7px; border-radius: 4px; margin: 2px 2px 0 0; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 600; }
.popup-tag.first { background: rgba(91,156,246,0.18); color: #5b9cf6; border: 1px solid rgba(91,156,246,0.25); }
.popup-tag.flexible { background: rgba(110,207,150,0.15); color: #6ecf96; border: 1px solid rgba(110,207,150,0.2); }
.popup-tag.asap { background: rgba(240,201,58,0.15); color: #f0c93a; border: 1px solid rgba(240,201,58,0.2); }
.popup-tag.remove { background: rgba(224,122,95,0.15); color: #e07a5f; border: 1px solid rgba(224,122,95,0.2); }
.popup-tag.service { background: rgba(0,0,0,0.05); color: rgba(0,0,0,0.42); border: 1px solid rgba(0,0,0,0.08); }
.popup-driver-row { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid rgba(0,0,0,0.06); }
.popup-driver-img { width: 38px; height: 38px; border-radius: 50%; object-fit: cover; border: 2px solid rgba(0,0,0,0.1); flex-shrink: 0; }
.popup-driver-info { flex: 1; }
.popup-driver-name { font-size: 12px; font-weight: 600; color: rgba(0,0,0,0.65); }
.popup-driver-phone { font-size: 11px; color: rgba(0,0,0,0.38); margin-top: 1px; }
.popup-link { font-size: 11px; color: rgba(240,201,58,0.8); text-decoration: none; margin-top: 8px; display: inline-block; transition: color 0.15s; }
.popup-link:hover { color: #f0c93a; text-decoration: underline; }
</style>
</head>
<body>

<!-- WORKSPACE -->
<div class="workspace">

  <!-- LEFT PANEL -->
  <div class="panel-left">
    <div class="panel-header">
      <div class="panel-title">
        Pending
        <span class="badge" id="queue-badge">0</span>
      </div>
      <div class="panel-search">
        <input type="text" placeholder="Search cards..." id="queue-search" oninput="filterQueue()" />
      </div>
    </div>
    <div class="cards-list" id="cards-list"
      ondragover="handleQueueDragOver(event)"
      ondragleave="handleQueueDragLeave(event)"
      ondrop="handleQueueDrop(event)">
      <div class="empty-state">
        <div class="icon">üì≠</div>
        <div class="title">No pending requests</div>
        <div class="sub">Cards will appear here when salespeople fill the RS field in Trello</div>
      </div>
    </div>
  </div>

  <!-- CENTER MAP -->
  <div class="map-container">
    <div id="map"></div>

    <!-- Day layer pills -->
    <div class="map-controls" id="map-controls">
      <!-- populated dynamically -->
    </div>

    <!-- Suggestion banner -->
    <div class="suggestion-banner" id="suggestion-banner">
      <div class="suggestion-text">
        <div class="suggestion-label">üí° Suggestion</div>
        <div class="suggestion-detail" id="sug-detail">‚Äî</div>
        <div class="suggestion-meta" id="sug-meta">‚Äî</div>
      </div>
      <div class="suggestion-actions">
        <button class="sug-btn confirm" onclick="confirmSuggestion()">Confirm</button>
        <button class="sug-btn adjust" onclick="openAssignModal(null, true)">Adjust</button>
        <button class="sug-btn dismiss" onclick="dismissSuggestion()">‚úï</button>
      </div>
    </div>
  </div>

  <!-- RIGHT PANEL -->
  <div class="panel-right">
    <div class="route-panel" id="route-panel">
      <!-- populated by JS -->
    </div>
    <div class="truck-c-wrap" id="truck-c-wrap">
      <button class="truck-c-btn" id="truck-b-btn" onclick="toggleTruckB()">+ Add Truck B</button>
      <button class="truck-c-btn" id="truck-c-btn" onclick="toggleTruckC()" style="display:none">+ Add Truck C</button>
    </div>
  </div>

</div>

<!-- Hidden driver-chips container (used by renderDriverBar) -->
<div id="driver-chips" style="display:none;"></div>

<!-- ASSIGN MODAL -->
<div class="modal-overlay" id="assign-modal">
  <div class="modal">
    <div class="modal-title" id="modal-title">Schedule Stop</div>
    <div class="modal-sub" id="modal-sub">Assign this card to a route</div>

    <div class="first-stop-section" id="first-stop-section" style="display:none">
      <div class="first-stop-title">ü•á First Stop Requested</div>
      <div class="first-stop-desc" id="first-stop-desc">Customer has requested first stop delivery.</div>
      <div class="first-stop-btns">
        <div class="fs-btn" id="fs-approve" onclick="setFirstStopStatus('approved')">‚úì Approve</div>
        <div class="fs-btn revoke" id="fs-revoke" onclick="setFirstStopStatus('revoked')">‚úó Revoke</div>
      </div>
    </div>

    <div class="modal-row">
      <div class="form-group">
        <label class="form-label">Day</label>
        <select class="form-select" id="modal-day">
          <option value="">Select day...</option>
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Truck</label>
        <select class="form-select" id="modal-truck">
          <option value="A">Truck A</option>
          <option value="B">Truck B</option>
          <option value="C">Truck C</option>
        </select>
      </div>
    </div>

    <div class="form-group">
      <label class="form-label">Driver</label>
      <select class="form-select" id="modal-driver">
        <option value="">Select driver...</option>
      </select>
    </div>

    <div class="form-group">
      <label class="form-label">Stop Position</label>
      <select class="form-select" id="modal-stop">
        <option value="auto">Auto (recommended)</option>
      </select>
    </div>

    <div class="modal-actions">
      <button class="btn-cancel" onclick="closeModal('assign-modal')">Cancel</button>
      <button class="btn-confirm" onclick="confirmAssign()">Schedule Stop</button>
    </div>
  </div>
</div>

<!-- SETTINGS OVERLAY -->
<div class="settings-overlay" id="settings-overlay">
  <div class="settings-panel">
    <div class="settings-title">‚öô Settings</div>
    <div class="settings-sub">CF Dispatch Tool ‚Äî Configuration</div>

    <div class="settings-section">
      <div class="settings-section-title">Trello Connection</div>
      <div class="form-group">
        <label class="form-label">API Token (your personal Trello token)</label>
        <input type="password" class="form-input" id="settings-token" placeholder="Paste your Trello token..." />
      </div>
      <div id="connection-status-wrap" style="display:none">
        <div class="connection-status" id="connection-status">
          <span id="conn-status-icon">‚úÖ</span>
          <span id="conn-status-text">Connected</span>
        </div>
      </div>
      <button class="connect-btn" onclick="saveSettings()">Save & Connect</button>
    </div>

    <div class="settings-section">
      <div class="settings-section-title">About</div>
      <div style="font-size:12px;color:rgba(0,0,0,0.42);line-height:1.7">
        <div>üìã Board: CF ASANA</div>
        <div>üóì Schedule window: 2 weeks</div>
        <div>üöõ Stop cap: 4 per truck</div>
        <div>üìç Warehouse: 3063 E Fruitland Ave, Vernon</div>
        <div>üè† HQ: 2251 Venice Blvd, Los Angeles</div>
      </div>
    </div>

    <button class="connect-btn" style="background:rgba(0,0,0,0.04);color:rgba(0,0,0,0.6);border:1px solid rgba(0,0,0,0.1);" onclick="closeModal('settings-overlay')">Close</button>
  </div>
</div>

<!-- CONFIRM DIALOG -->
<div class="confirm-dialog" id="confirm-dialog">
  <div class="confirm-box">
    <div class="confirm-icon" id="confirm-icon">‚ö†Ô∏è</div>
    <div class="confirm-title" id="confirm-title">Are you sure?</div>
    <div class="confirm-msg" id="confirm-msg">This action cannot be undone.</div>
    <div class="confirm-actions">
      <button class="confirm-cancel" onclick="closeModal('confirm-dialog')">Cancel</button>
      <button class="confirm-ok" id="confirm-ok-btn">Confirm</button>
    </div>
  </div>
</div>

<!-- TOAST CONTAINER -->
<div class="toast-container" id="toast-container"></div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONSTANTS & CONFIG
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const API_KEY = 'TRELLO_API_KEY_PLACEHOLDER';
let TOKEN = localStorage.getItem('cf_dispatch_token') || 'TRELLO_TOKEN_PLACEHOLDER';

const BOARD_ID = 'GpVORoMM';
const HIDDEN_BOARD_ID = '6965633f4fe5254c47e38527';
const DRIVERS_LIST_ID = '699df279600f35c809d451af';

const CUSTOM_FIELDS = {
  INV_TOTAL: '696ec194757d725c25438f82',
  AQREF:     '69711644a396debf23689c94',
  RS:        '699deaf8ae2995aa04f30441',
  OT:        '69839631a61d2fa52d6c0699',
};

const FRUITLAND = { lat: 33.9989, lng: -118.2054, name: 'CF Fruitland' };
const HQ = { lat: 34.043654, lng: -118.307807, name: "CF Venice" };

const LANDMARK_INFO = {
  'CF Venice': `<div class="lm-t">Charlie's Fixtures</div><div class="lm-r">2251 Venice Blvd., Los Angeles CA 90006</div><div class="lm-r">üìû 323-731-9023</div><div class="lm-h">üïê Mon‚ÄìFri 8am‚Äì5pm ¬∑ Sat 8am‚Äì4pm</div>`,
  'CF Fruitland': `<div class="lm-t">Fruitland Warehouse</div><div class="lm-r">3063 E. Fruitland Ave., Vernon CA 90059</div><div class="lm-r">üìû 323-584-6122</div><div class="lm-h">üïê Mon‚ÄìFri 8am‚Äì1pm &amp; 1:30pm‚Äì4:30pm</div>`
};

const DAY_COLORS = {
  MON: '#f0c93a', TUE: '#4f8eff', WED: '#7ed6a0',
  THU: '#e07a5f', FRI: '#c084fc'
};

const DAY_COLORS_W2 = {
  MON: '#e6a817', TUE: '#2d7aed', WED: '#3dba78',
  THU: '#c9553c', FRI: '#9b5de5'
};

function getDayColor(day, key) {
  return (key && key.includes('W2')) ? (DAY_COLORS_W2[day] || DAY_COLORS[day]) : (DAY_COLORS[day] || '#f0c93a');
}

const DAYS = ['MON','TUE','WED','THU','FRI'];
const MAX_STOPS = 4;
const OVERFLOW_RADIUS_MILES = 2;
const AWAY_WARNING_DAYS = 10;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let state = {
  drivers: [],           // [{id, name, photo, truckDefault, unavailableFrom, unavailableUntil}]
  queueCards: [],        // unscheduled cards from "Requested for Schedule"
  schedule: {},          // { 'MON-W1': { A: [...stops], B: [...stops], C: [...stops] } }
  selectedCard: null,
  activeDayFilter: 'ALL',
  activeWeek: 1,
  activeRightDay: 'MON-W1',
  pendingSuggestion: null,
  expandedCard: null,
  lockedTrucks: {},      // { 'MON-W1-A': true }
  showTruckB: false,     // hidden by default ‚Äî Truck A only at start
  showTruckC: false,     // hidden by default
  mapMarkers: {},
  mapRouteLines: {},
  unscheduledMarkers: [],
  truckDrivers: {},      // { 'MON-W1-A': driverId, 'MON-W1-B': driverId } ‚Äî manager-assigned per day
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TRELLO API
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function trello(path, method = 'GET', body = null) {
  const sep = path.includes('?') ? '&' : '?';
  const url = `https://api.trello.com/1${path}${sep}key=${API_KEY}&token=${TOKEN}`;
  const opts = { method, headers: { 'Content-Type': 'application/json' } };
  if (body) opts.body = JSON.stringify(body);
  try {
    const r = await fetch(url, opts);
    if (r.status === 401) throw new Error('AUTH');
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    return await r.json();
  } catch(e) {
    if (e.message === 'AUTH') {
      setSyncStatus('error', 'Auth failed ‚Äî check token in Settings');
      openSettings();
    }
    throw e;
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GEOCODING (free Nominatim)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const geocodeCache = {};

async function geocode(address) {
  if (geocodeCache[address]) return geocodeCache[address];
  try {
    const r = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`, {
      headers: { 'User-Agent': 'CFDispatch/1.0' }
    });
    const data = await r.json();
    if (data.length > 0) {
      const result = { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon) };
      geocodeCache[address] = result;
      return result;
    }
    return null;
  } catch { return null; }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// DISTANCE UTILITIES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function distanceMiles(a, b) {
  const R = 3958.8;
  const dLat = (b.lat - a.lat) * Math.PI / 180;
  const dLng = (b.lng - a.lng) * Math.PI / 180;
  const x = Math.sin(dLat/2) ** 2 +
    Math.cos(a.lat * Math.PI/180) * Math.cos(b.lat * Math.PI/180) * Math.sin(dLng/2) ** 2;
  return R * 2 * Math.atan2(Math.sqrt(x), Math.sqrt(1-x));
}

function bearingDeg(from, to) {
  const dLng = (to.lng - from.lng) * Math.PI / 180;
  const lat1 = from.lat * Math.PI / 180;
  const lat2 = to.lat * Math.PI / 180;
  const y = Math.sin(dLng) * Math.cos(lat2);
  const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLng);
  return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
}

function bearingDiff(a, b) {
  const d = Math.abs(a - b) % 360;
  return d > 180 ? 360 - d : d;
}

// Total loop distance: Fruitland ‚Üí stops in order ‚Üí HQ
function loopDistance(stops) {
  if (!stops.length) return 0;
  let d = distanceMiles(FRUITLAND, stops[0].coords);
  for (let i = 1; i < stops.length; i++) d += distanceMiles(stops[i-1].coords, stops[i].coords);
  d += distanceMiles(stops[stops.length-1].coords, HQ);
  return d;
}

// Best insertion position for new stop in existing sequence
function bestInsertPosition(existing, newCoords) {
  if (!existing.length) return 0;
  let bestPos = 0, bestDist = Infinity;
  for (let i = 0; i <= existing.length; i++) {
    const test = [...existing.slice(0, i), { coords: newCoords }, ...existing.slice(i)];
    const d = loopDistance(test);
    if (d < bestDist) { bestDist = d; bestPos = i; }
  }
  return bestPos;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// DATE UTILITIES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function getWeekDates(weekOffset = 0) {
  // Rolling 10-day window: always returns next 10 working days from today
  // weekOffset 0 = days 1-5, weekOffset 1 = days 6-10
  const allDays = getNext10WorkingDays();
  const start = weekOffset * 5;
  return allDays.slice(start, start + 5);
}

function getNext10WorkingDays() {
  const days = [];
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const cursor = new Date(today);
  let weekNum = 1;
  let count = 0;

  while (days.length < 10) {
    const dow = cursor.getDay();
    if (dow !== 0 && dow !== 6) { // Skip weekends
      count++;
      if (count > 5) weekNum = 2;
      const dayName = DAYS[dow - 1]; // DAYS = ['MON','TUE','WED','THU','FRI']
      days.push({
        day: dayName,
        date: new Date(cursor),
        key: `${dayName}-W${weekNum}`
      });
    }
    cursor.setDate(cursor.getDate() + 1);
  }
  return days;
}

function workingDaysBetween(a, b) {
  let count = 0;
  const d = new Date(a);
  while (d < b) {
    const day = d.getDay();
    if (day !== 0 && day !== 6) count++;
    d.setDate(d.getDate() + 1);
  }
  return count;
}

function dayName(date) {
  return ['SUN','MON','TUE','WED','THU','FRI','SAT'][date.getDay()];
}

function dueTimestamp(date) {
  // 5:00 PM Pacific ‚Äî detect DST
  const testDate = new Date(date);
  const offset = testDate.toLocaleString('en-US', { timeZone: 'America/Los_Angeles', timeZoneName: 'short' }).includes('PDT') ? 7 : 8;
  const utcHour = 17 + offset;
  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), utcHour - 24 > 0 ? utcHour - 24 : utcHour, 0, 0)).toISOString();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PARSE RS FIELD
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const ASAP_KEYWORDS = ['asap','urgent','rush','emergency','stat','critical','now','today','immediately','immed','rn'];
const FLEXIBLE_KEYWORDS = ['flex','flexible','any','anytime','no preference','no pref','none','tbd','open','whenever','no rush','nr','na','n/a','idc','dont care',"don't care",'whatever','w/e','later','no date','no hurry','nh','np','whenever works','when available','next available','next avail','schedule me','fit me in','no specific'];

function parseRS(val) {
  if (!val || !val.trim()) return { type: 'empty' };
  const v = val.trim().toLowerCase();
  if (ASAP_KEYWORDS.some(k => v.includes(k))) return { type: 'asap' };
  if (FLEXIBLE_KEYWORDS.some(k => v.includes(k))) return { type: 'flexible' };

  // Try to parse as date
  const cleaned = val.replace(/[-‚Äì]/g, '/').replace(/\b([a-z]+)\s+(\d+)/i, '$1 $2');
  const parsed = new Date(cleaned + (cleaned.match(/\d{4}/) ? '' : `/${new Date().getFullYear()}`));
  if (!isNaN(parsed.getTime())) {
    const today = new Date(); today.setHours(0,0,0,0);
    if (parsed < today) return { type: 'past', date: parsed };
    return { type: 'date', date: parsed };
  }
  return { type: 'unknown', raw: val };
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// DRIVER STATUS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function getDriverStatus(driver) {
  const today = new Date(); today.setHours(0,0,0,0);
  const from = driver.unavailableFrom ? new Date(driver.unavailableFrom) : null;
  const until = driver.unavailableUntil ? new Date(driver.unavailableUntil) : null;

  if (!from && !until) return { available: true, label: null };

  if (from && until) {
    if (today >= from && today <= until) {
      const days = workingDaysBetween(today, until);
      return { available: false, label: `returns in ${days} day${days !== 1 ? 's' : ''} (${dayName(until)})` };
    }
    if (today < from) {
      const days = workingDaysBetween(today, from);
      if (days <= AWAY_WARNING_DAYS) {
        return { available: true, label: `away in ${days} day${days !== 1 ? 's' : ''} (${dayName(from)})` };
      }
    }
  }
  return { available: true, label: null };
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RECOMMENDATION ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function recommend(card) {
  const results = recommendMultiple(card, 1);
  return results.length > 0 ? results[0] : null;
}

function recommendMultiple(card, limit = 5) {
  if (!card.coords) return [];

  const week1 = getWeekDates(0);
  const week2 = getWeekDates(1);
  const allDays = [...week1, ...week2];

  const rsInfo = parseRS(card.rsValue);
  let preferredDate = null;
  if (rsInfo.type === 'date') preferredDate = rsInfo.date;

  const options = [];

  for (const { day, date, key } of allDays) {
    const todayDate = new Date(); todayDate.setHours(0,0,0,0);
    if (date <= todayDate) continue; // Skip today and past ‚Äî earliest recommendation is tomorrow

    const isPreferredDay = preferredDate && (() => {
      const pDate = new Date(preferredDate); pDate.setHours(0,0,0,0);
      const dDate = new Date(date); dDate.setHours(0,0,0,0);
      return pDate.getTime() === dDate.getTime();
    })();

    const trucksToShow = ['A', 'B', ...( (state.showTruckC || Object.keys(state.schedule[key]?.C || {}).length > 0 || (state.schedule[key]?.C || []).length > 0) ? ['C'] : [] )];
    for (const truck of trucksToShow) {
      const truckKey = `${key}-${truck}`;
      if (state.lockedTrucks[truckKey]) continue;

      const stops = state.schedule[key]?.[truck] || [];
      if (stops.length >= MAX_STOPS) {
        const minDist = stops.reduce((min, s) => Math.min(min, distanceMiles(card.coords, s.coords)), Infinity);
        if (minDist > OVERFLOW_RADIUS_MILES) continue;
      }

      // Direction check
      const dayStops = [
        ...(state.schedule[key]?.A || []),
        ...(state.schedule[key]?.B || []),
        ...(state.schedule[key]?.C || [])
      ];

      let directionPenalty = 0;
      if (dayStops.length > 0) {
        const centroidLat = dayStops.reduce((s, x) => s + x.coords.lat, 0) / dayStops.length;
        const centroidLng = dayStops.reduce((s, x) => s + x.coords.lng, 0) / dayStops.length;
        const routeBearing = bearingDeg(FRUITLAND, { lat: centroidLat, lng: centroidLng });
        const cardBearing = bearingDeg(FRUITLAND, card.coords);
        const diff = bearingDiff(routeBearing, cardBearing);
        if (diff > 45) directionPenalty = diff;
      }

      const minDist = stops.length > 0
        ? stops.reduce((min, s) => Math.min(min, distanceMiles(card.coords, s.coords)), Infinity)
        : distanceMiles(card.coords, FRUITLAND);

      // Score: lower is better
      let score = minDist + (directionPenalty * 0.1);

      // colorScore: operational likelihood only (no RS preference bias)
      // Used for green/gold/red display ‚Äî reflects slot quality, not date preference
      let colorScore = minDist + (directionPenalty * 0.1);

      // Preferred date bonus: massive score reduction if this is the requested day
      if (isPreferredDay) {
        score -= 1000; // Strongly prefer the requested date
      } else if (preferredDate) {
        // If they have a preferred date but this isn't it, penalize heavily
        score += 500;
      } else {
        // No preferred date ‚Äî favor earlier days slightly
        score += (date - new Date()) / 86400000 * 0.5;
      }

      // Capacity bonus: emptier routes score better (higher chance of approval)
      const capacityBonus = (MAX_STOPS - stops.length) * 2;
      score -= capacityBonus;
      colorScore -= capacityBonus;

      // Empty route = guaranteed green ‚Äî no roadblocks
      if (stops.length === 0) colorScore = -10;

      // Rider bonus: if card is flagged as rider and truck has stops, 
      // give a big bonus when the card is close to an existing stop (in-route match)
      let isInRouteMatch = false;
      if (card.rider && stops.length > 0 && minDist < 5) {
        score -= 200; // Strong bonus for nearby route match
        isInRouteMatch = true;
      }

      const insertPos = bestInsertPosition(stops, card.coords);

      options.push({
        dayKey: key, day, date, truck, insertPos, minDist,
        overflow: stops.length >= MAX_STOPS,
        isPreferredDay: !!isPreferredDay,
        isInRouteMatch,
        stopsOnTruck: stops.length,
        score,
        colorScore
      });
    }
  }

  // Sort by score (lower = better)
  options.sort((a, b) => a.score - b.score);

  // If no options and routes are full, add overflow fallback
  if (options.length === 0) {
    const futureDays = allDays.filter(d => d.date >= new Date(new Date().setHours(0,0,0,0)));
    const lastDay = futureDays[futureDays.length - 1];
    if (lastDay) {
      const nextDate = new Date(lastDay.date);
      nextDate.setDate(nextDate.getDate() + 1);
      while (nextDate.getDay() === 0 || nextDate.getDay() === 6) {
        nextDate.setDate(nextDate.getDate() + 1);
      }
      const dayNames = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
      options.push({
        dayKey: null, day: dayNames[nextDate.getDay()], date: nextDate,
        truck: 'A', insertPos: 0, minDist: distanceMiles(card.coords, FRUITLAND),
        overflow: false, routesFull: true, nextAvailableDate: nextDate,
        isPreferredDay: false, stopsOnTruck: 0, score: 9999
      });
    }
  }

  // Deduplicate by date ‚Äî show best option per unique day
  const seenDays = new Set();
  const uniqueDateOptions = [];
  for (const opt of options) {
    const dateKey = opt.date.toDateString();
    if (!seenDays.has(dateKey)) {
      seenDays.add(dateKey);
      uniqueDateOptions.push(opt);
    }
    if (uniqueDateOptions.length >= limit) break;
  }

  return uniqueDateOptions;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAP SETUP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let map;

function initMap() {
  map = L.map('map', { zoomControl: false }).setView([34.02, -118.35], 11);

  L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png?api_key=STADIA_API_KEY_PLACEHOLDER', {
    maxZoom: 18,
    attribution: '¬© Stadia Maps ¬© OpenMapTiles ¬© OpenStreetMap'
  }).addTo(map);

  L.control.zoom({ position: 'bottomright' }).addTo(map);

  // Permanent landmarks
  addLandmarkPin(FRUITLAND, '#f0c93a');
  addLandmarkPin(HQ, '#4f8eff');
}

function addLandmarkPin(loc, color) {
  // Convert hex to rgba for ring and glow
  const hex = color.replace('#','');
  const r = parseInt(hex.substring(0,2),16);
  const g = parseInt(hex.substring(2,4),16);
  const b = parseInt(hex.substring(4,6),16);
  const ringColor = `rgba(${r},${g},${b},0.5)`;
  const glowColor = `rgba(${r},${g},${b},0.15)`;
  const icon = L.divIcon({
    className: '',
    html: `<div class="landmark-pin"><div class="landmark-icon" style="background:rgba(235,230,220,0.7);backdrop-filter:blur(12px) saturate(1.5) brightness(1.1);-webkit-backdrop-filter:blur(12px) saturate(1.5) brightness(1.1);border:2px solid ${ringColor};padding:4px;border-radius:10px;box-shadow:0 0 0 4px ${glowColor}, 0 2px 12px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.5);"><img src="assets/cf-pin.png" width="28" height="28" style="display:block;border-radius:4px;" /></div></div>`,
    iconSize: [42, 42],
    iconAnchor: [21, 21],
  });
  L.marker([loc.lat, loc.lng], { icon, zIndexOffset: -100 })
    .bindTooltip(LANDMARK_INFO[loc.name] || loc.name, { permanent: false, direction: 'right', offset: [18, 0], className: 'landmark-tip', interactive: false })
    .addTo(map);
}

function createDriverPin(driver, stopNum, dayColor) {
  const html = `
    <div class="driver-pin">
      <img src="assets/${driver.name.split(' ')[0].toLowerCase()}.png" onerror="this.style.background='#2e3850';this.src=''" alt="${driver.name}" />
      <div class="stop-badge" style="background:${dayColor}">${stopNum}</div>
    </div>`;
  return L.divIcon({ className: '', html, iconSize: [36, 36], iconAnchor: [18, 18] });
}

function createUnscheduledPin(urgency) {
  const cls = urgency === 'asap' ? 'unscheduled-pin asap' : 'unscheduled-pin';
  return L.divIcon({ className: '', html: `<div class="${cls}"></div>`, iconSize: [10,10], iconAnchor: [5,5] });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER MAP STOPS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚îÄ‚îÄ ROUTE PREVIEW ON ALGO STRIP HOVER ‚îÄ‚îÄ
let previewLayer = null;
let previewMarker = null;

function showRoutePreview(cardId, dayKey, truck, insertPos) {
  clearRoutePreview();

  const card = state.queueCards.find(c => c.id === cardId);
  if (!card?.coords) return;

  // Get existing stops for this truck on this day
  const existingStops = (state.schedule[dayKey]?.[truck] || []).filter(s => s.coords);
  
  // Build the route with this card inserted at the recommended position
  const stopCoords = existingStops.map(s => s.coords);
  stopCoords.splice(insertPos, 0, card.coords);

  // Full route: Warehouse ‚Üí stops ‚Üí HQ
  const routePoints = [FRUITLAND, ...stopCoords, HQ].map(p => [p.lat, p.lng]);

  // Draw preview polyline ‚Äî golden dashed, semi-transparent
  previewLayer = L.polyline(routePoints, {
    color: '#F0C93A',
    weight: 4,
    opacity: 0.7,
    dashArray: '10 6',
    smoothFactor: 2,
  }).addTo(map);

  // Pulsing marker at the card's position
  const pulseHtml = `
    <div style="position:relative;width:32px;height:32px">
      <div style="position:absolute;inset:0;background:rgba(240,201,58,0.3);border-radius:50%;animation:pulse-ring 1.5s ease-out infinite"></div>
      <div style="position:absolute;top:4px;left:4px;width:24px;height:24px;background:#F0C93A;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:800;color:#000;border:2px solid white;box-shadow:0 2px 8px rgba(0,0,0,0.3)">${insertPos + 1}</div>
    </div>`;
  
  previewMarker = L.marker([card.coords.lat, card.coords.lng], {
    icon: L.divIcon({ className: '', html: pulseHtml, iconSize: [32, 32], iconAnchor: [16, 16] }),
    zIndexOffset: 1000
  }).addTo(map);

  // Add CSS animation if not already present
  if (!document.getElementById('pulse-style')) {
    const style = document.createElement('style');
    style.id = 'pulse-style';
    style.textContent = `@keyframes pulse-ring { 0% { transform: scale(0.8); opacity: 1; } 100% { transform: scale(2); opacity: 0; } }`;
    document.head.appendChild(style);
  }
}

function clearRoutePreview() {
  if (previewLayer) { previewLayer.remove(); previewLayer = null; }
  if (previewMarker) { previewMarker.remove(); previewMarker = null; }
}

function renderMap() {
  // Clear preview if active
  clearRoutePreview();
  // Clear existing
  Object.values(state.mapMarkers).flat().forEach(m => m.remove());
  Object.values(state.mapRouteLines).flat().forEach(l => l.remove());
  state.unscheduledMarkers.forEach(m => m.remove());
  state.mapMarkers = {};
  state.mapRouteLines = {};
  state.unscheduledMarkers = [];

  const allDays = [...getWeekDates(0), ...getWeekDates(1)];
  const activeFilter = state.activeDayFilter;

  for (const { day, key } of allDays) {
    if (activeFilter !== 'ALL' && key !== activeFilter) continue;

    const weekNum = key.includes('W1') ? 1 : 2;
    const dayColor = getDayColor(day, key);
    const daySchedule = state.schedule[key] || {};

    for (const [truck, stops] of Object.entries(daySchedule)) {
      if (!stops.length) continue;

      const driver = getDriverForTruck(key, truck);
      const driverOrFallback = driver || state.drivers[0]; // fallback for route planning, not for pins
      const routePoints = [FRUITLAND, ...stops.map(s => s.coords), HQ];

      // Route line ‚Äî Truck B gets lighter opacity to differentiate
      const truckOpacity = truck === 'A' ? 0.6 : 0.4;
      const truckWeight = truck === 'A' ? (weekNum === 2 ? 3 : 2.5) : (weekNum === 2 ? 2.5 : 2);
      const line = L.polyline(
        routePoints.map(p => [p.lat, p.lng]),
        {
          color: dayColor,
          weight: truckWeight,
          opacity: truckOpacity,
          dashArray: weekNum === 2 ? '8 4' : '6 3',
          smoothFactor: 2,
          className: `route-line route-${key}-${truck}`,
        }
      ).addTo(map);
      line._routeKey = key;
      line._routeTruck = truck;

      if (!state.mapRouteLines[key]) state.mapRouteLines[key] = [];
      state.mapRouteLines[key].push(line);

      // Stop pins ‚Äî circle for Truck A, rounded square for Truck B
      stops.forEach((stop, i) => {
        if (!stop.coords) return;
        const radius = truck === 'A' ? '50%' : '6px';
        const icon = L.divIcon({
          className: '',
          html: `<div style="background:${dayColor};width:24px;height:24px;border-radius:${radius};display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:700;color:#000;border:2px solid white;box-shadow:0 1px 4px rgba(0,0,0,0.15)">${i+1}</div>`,
          iconSize: [24, 24],
          iconAnchor: [12, 12]
        });

        const dayNames = { MON: 'Mon', TUE: 'Tue', WED: 'Wed', THU: 'Thu', FRI: 'Fri' };
        const dates = [...getWeekDates(0), ...getWeekDates(1)];
        const dayInfo = dates.find(d => d.key === key);
        const dateLabel = dayInfo ? dayInfo.date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }) : key;
        const stopOwner = stop.requesterName || stop.salesperson || 'Unassigned';
        const statusLabel = stop.committed ? 'Scheduled' : 'Pending';
        const statusClass = stop.committed ? 'dt-scheduled' : 'dt-pending';
        const stopTipHtml = `<div class="dt-name">${stop.name}</div><div class="dt-owner">\u{1F464} ${stopOwner}</div><div class="dt-status"><span class="${statusClass}">\u25CF ${statusLabel} \u00B7 ${dateLabel}</span></div>`;

        const marker = L.marker([stop.coords.lat, stop.coords.lng], { icon })
          .bindTooltip(stopTipHtml, { permanent: false, direction: 'right', offset: [12, 0], className: 'dot-tip', interactive: false })
          .addTo(map);

        if (!state.mapMarkers[key]) state.mapMarkers[key] = [];
        state.mapMarkers[key].push(marker);
      });
    }
  }

  // Unscheduled dots
  if (activeFilter === 'ALL' || !activeFilter) {
    state.queueCards.forEach((card, idx) => {
      if (!card.coords) return;
      const owner = card.requesterName || card.salesperson || 'Unassigned';
      const tipHtml = `<div class="dt-name">${card.name}</div><div class="dt-owner">\u{1F464} ${owner}</div><div class="dt-status"><span class="dt-pending">\u25CF Pending</span></div>`;
      const urgency = parseRS(card.rsValue).type === 'asap' ? 'asap' : 'normal';
      const marker = L.marker([card.coords.lat, card.coords.lng], { icon: createUnscheduledPin(urgency) })
        .bindTooltip(tipHtml, { permanent: false, direction: 'right', offset: [12, 0], className: 'dot-tip', interactive: false })
        .addTo(map);
      marker._cardId = card.id;
      state.unscheduledMarkers.push(marker);
    });
  }
  updateRouteAnimation();
}

// ‚îÄ‚îÄ ROUTE ANIMATION CONTROL ‚îÄ‚îÄ
// Determines which route lines animate based on current view state:
// ALL + no selection ‚Üí all animate
// ALL + card selected ‚Üí only that card's route animates, others dim
// Day + no selection ‚Üí all routes for that day animate
// Day + card selected ‚Üí only that card's route animates, others dim
function updateRouteAnimation() {
  const activeFilter = state.activeDayFilter;
  const selectedCard = state.selectedCard;

  // Find which route the selected card is on (if scheduled)
  let selectedRouteKey = null;
  let selectedRouteTruck = null;
  if (selectedCard) {
    for (const [key, daySchedule] of Object.entries(state.schedule)) {
      for (const [truck, stops] of Object.entries(daySchedule)) {
        if (stops.some(s => s.cardId === selectedCard.id || s.id === selectedCard.id)) {
          selectedRouteKey = key;
          selectedRouteTruck = truck;
          break;
        }
      }
      if (selectedRouteKey) break;
    }
  }

  // Apply animation classes to all route lines
  for (const [key, lines] of Object.entries(state.mapRouteLines)) {
    lines.forEach(line => {
      const el = line.getElement?.();
      if (!el) return;

      // Reset classes
      el.classList.remove('route-animate', 'route-dim');

      if (selectedCard && selectedRouteKey) {
        // Card is selected AND it's on a route
        if (line._routeKey === selectedRouteKey && line._routeTruck === selectedRouteTruck) {
          el.classList.add('route-animate');
        } else {
          el.classList.add('route-dim');
        }
      } else {
        // No card selected (or card is still pending) ‚Äî animate all visible routes
        el.classList.add('route-animate');
      }
    });
  }
}

function buildPopupHTML(stop) {
  // Find which driver is assigned to this stop
  const dayKey = stop.dayKey || state.activeRightDay;
  const truck = stop.truck || '';
  const driver = getDriverForTruck(dayKey, truck)
    || state.drivers?.find(d => d.id === stop.driverId);
  const driverFirstName = driver?.name?.split(' ')[0]?.toLowerCase() || '';

  const tags = [
    stop.firstStopApproved && `<span class="popup-tag first">First Stop</span>`,
    stop.rs === 'ASAP' && `<span class="popup-tag asap">ASAP</span>`,
    stop.rs === 'FLEXIBLE' && `<span class="popup-tag flexible">Flexible</span>`,
    stop.weightGate && `<span class="popup-tag service">Weight Gate</span>`,
    stop.equipRemoval && `<span class="popup-tag remove">Equip Removal</span>`,
  ].filter(Boolean).join('');

  return `<div>
    ${driver ? `
    <div class="popup-driver-row">
      <img class="popup-driver-img" src="assets/${driverFirstName}.png" onerror="this.style.display='none'" alt="${driver.name}" />
      <div class="popup-driver-info">
        <div class="popup-driver-name">${driver.name}</div>
        <div class="popup-driver-phone">${driver.phone || 'No phone on file'}</div>
      </div>
    </div>` : ''}
    <div class="popup-title">${stop.cardName || stop.name}</div>
    ${stop.address ? `<div class="popup-row"><span class="popup-icon">üìç</span><strong>${stop.address}</strong></div>` : ''}
    <div class="popup-divider"></div>
    ${stop.customerName ? `<div class="popup-row"><span class="popup-icon">üë§</span> ${stop.customerName}</div>` : ''}
    ${stop.customerPhone ? `<div class="popup-row"><span class="popup-icon">üìû</span> <strong>${stop.customerPhone}</strong></div>` : '<div class="popup-row" style="opacity:0.3">üìû No contact on file</div>'}
    ${stop.salesperson ? `<div class="popup-row"><span class="popup-icon">üßë‚Äçüíº</span> ${stop.salesperson}</div>` : ''}
    ${stop.invTotal ? `<div class="popup-row"><span class="popup-icon">üí∞</span> $${parseFloat(stop.invTotal).toLocaleString()}</div>` : ''}
    ${tags ? `<div style="margin-top:8px;">${tags}</div>` : ''}
    ${stop.notes ? `<div class="popup-divider"></div><div class="popup-row" style="font-style:italic;opacity:0.7">üí¨ ${stop.notes}</div>` : ''}
    <a class="popup-link" href="https://trello.com/c/${stop.cardShortId || stop.shortLink}" target="_blank">Open in Trello ‚Üí</a>
  </div>`;
}

function buildQueuePopupHTML(card) {
  const tags = [
    card.rs && `<span class="popup-tag ${card.rs === 'ASAP' ? 'asap' : card.rs === 'FLEXIBLE' ? 'flexible' : 'service'}">${card.rs}</span>`,
    card.firstStop && `<span class="popup-tag first">First Stop</span>`,
    card.weightGate && `<span class="popup-tag service">Weight Gate</span>`,
    card.equipRemoval && `<span class="popup-tag remove">Equip Removal</span>`,
    card.stairs && `<span class="popup-tag service">Stairs</span>`,
  ].filter(Boolean).join('');

  return `<div>
    <div class="popup-title">${card.name}</div>
    ${card.address ? `<div class="popup-row"><span class="popup-icon">üìç</span> <strong>${card.address}</strong></div>` : ''}
    <div class="popup-divider"></div>
    ${card.customerName ? `<div class="popup-row"><span class="popup-icon">üë§</span> ${card.customerName}</div>` : ''}
    ${card.customerPhone ? `<div class="popup-row"><span class="popup-icon">üìû</span> <strong>${card.customerPhone}</strong></div>` : '<div class="popup-row" style="opacity:0.3">üìû No contact on file</div>'}
    ${card.salesperson ? `<div class="popup-row"><span class="popup-icon">üßë‚Äçüíº</span> ${card.salesperson}</div>` : ''}
    ${card.invTotal ? `<div class="popup-row"><span class="popup-icon">üí∞</span> $${parseFloat(card.invTotal).toLocaleString()}</div>` : ''}
    ${tags ? `<div style="margin-top:8px;">${tags}</div>` : ''}
    ${card.notes ? `<div class="popup-divider"></div><div class="popup-row" style="font-style:italic;opacity:0.7">üí¨ ${card.notes}</div>` : ''}
    <a class="popup-link" href="https://trello.com/c/${card.shortLink}" target="_blank">Open in Trello ‚Üí</a>
  </div>`;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER LEFT PANEL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function renderQueue() {
  const list = document.getElementById('cards-list');
  const badge = document.getElementById('queue-badge');
  const search = document.getElementById('queue-search').value.toLowerCase();

  // Sort queue: RS date ascending (earliest requested first), then card creation date (oldest first)
  state.queueCards.sort((a, b) => {
    const rsA = parseRS(a.rsValue);
    const rsB = parseRS(b.rsValue);
    
    // Cards with specific dates go first, sorted by date ascending
    const dateA = rsA.type === 'date' ? rsA.date.getTime() : Infinity;
    const dateB = rsB.type === 'date' ? rsB.date.getTime() : Infinity;
    if (dateA !== dateB) return dateA - dateB;
    
    // Then by Trello card creation (embedded in card ID ‚Äî first 8 hex chars)
    const createdA = parseInt(a.id?.substring(0, 8), 16) || 0;
    const createdB = parseInt(b.id?.substring(0, 8), 16) || 0;
    return createdA - createdB;
  });

  const filtered = state.queueCards.filter(c =>
    c.name.toLowerCase().includes(search) ||
    (c.address || '').toLowerCase().includes(search)
  );

  badge.textContent = state.queueCards.length;
  badge.className = 'badge' + (state.queueCards.length > 0 ? ' has-items' : '');

  if (!filtered.length) {
    list.innerHTML = `<div class="empty-state">
      <div class="icon">üì≠</div>
      <div class="title">${search ? 'No matches' : 'No pending requests'}</div>
      <div class="sub">${search ? 'Try a different search' : 'Cards will appear here when salespeople fill the RS field in Trello'}</div>
    </div>`;
    return;
  }

  list.innerHTML = filtered.map(card => buildQueueCard(card)).join('');
}

function buildQueueCard(card) {
  const isSelected = state.selectedCard?.id === card.id;
  const isExpanded = state.expandedCard === card.id;
  const warningClass = (!card.address || !card.coords) ? 'has-warning' : '';

  // Avatar (card owner / salesperson)
  let avatarHtml = '';
  if (card.requesterAvatar) {
    avatarHtml = `<img class="qc-avatar" src="${card.requesterAvatar}" title="${card.requesterName || 'Card Owner'}" />`;
  } else if (card.requesterName) {
    const initials = card.requesterName.split(' ').map(n => n[0]).join('');
    avatarHtml = `<div class="qc-avatar-initials" title="${card.requesterName}">${initials}</div>`;
  }

  // Tags ‚Äî monotone
  const quadrant = card.quadrant || '';
  const rsInfo = parseRS(card.rsValue);
  let rsDisplay = 'Flexible';
  if (rsInfo.type === 'asap') rsDisplay = 'ASAP';
  else if (rsInfo.type === 'date') rsDisplay = rsInfo.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  else if (rsInfo.type === 'past') rsDisplay = '‚ö† Past date';
  else if (rsInfo.type === 'flexible') rsDisplay = 'Flexible';
  else if (card.rsValue && card.rsValue !== '') rsDisplay = card.rsValue;

  // Algo strip ‚Äî show top 2 recommendations with RS context
  let algoStrip = '';
  if (!card.coords) {
    algoStrip = `<div class="algo-strip" style="background:rgba(200,100,50,0.06)">
      <span class="algo-icon" style="opacity:0.8">‚ö†</span>
      <span style="color:rgba(180,90,40,0.6);font-weight:500;font-size:11px;font-family:'Inter Tight',sans-serif">Address required for routing</span>
    </div>`;
  } else {
    const recs = recommendMultiple(card, 3);
    const dayNames = { MON: 'Mon', TUE: 'Tue', WED: 'Wed', THU: 'Thu', FRI: 'Fri' };

    // Score ‚Üí color: green (<5 = likely), gold (5-20 = possible), red (>20 = unlikely)
    function algoColor(score) {
      if (score < 5) return 'rgba(76,155,60,0.85)';   // green ‚Äî high likelihood
      if (score <= 20) return 'rgba(190,150,40,0.8)';  // gold ‚Äî moderate
      return 'rgba(200,85,60,0.8)';                     // red ‚Äî low likelihood
    }

    if (recs.length > 0 && recs[0].routesFull) {
      const dateStr = recs[0].nextAvailableDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
      const nextDayColor = getDayColor(recs[0].nextAvailableDate.toLocaleDateString('en-US',{weekday:'short'}).toUpperCase().slice(0,3), '');
      algoStrip = `<div class="algo-strip" style="background:rgba(180,130,40,0.06)">
        <span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${nextDayColor};flex-shrink:0"></span>
        <span style="color:rgba(160,110,30,0.65);font-weight:600;font-size:11px;font-family:'Inter Tight',sans-serif">Routes full</span>
        <span style="color:rgba(160,110,30,0.45);font-size:10.5px;font-family:'Inter Tight',sans-serif">¬∑ Next opening ${dateStr}</span>
      </div>`;
    } else if (recs.length > 0) {
      // Best recommendation
      const best = recs[0];
      const dateStr = best.date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
      const color = algoColor(best.colorScore);
      const dayColor = getDayColor(best.dayKey.split('-')[0], best.dayKey);
      const prefLabel = best.isPreferredDay ? '<span style="font-size:9px;font-weight:700;margin-left:4px">‚òÖ REQUESTED</span>' : '';
      const riderMatch = (card.rider && best.isInRouteMatch) ? '<span style="color:rgba(100,80,180,0.8);font-size:9px;font-weight:700;margin-left:4px">üè∑ IN-ROUTE</span>' : '';

      algoStrip = `<div class="algo-strip" 
        onmouseenter="showRoutePreview('${card.id}','${best.dayKey}','${best.truck}',${best.insertPos})"
        onmouseleave="clearRoutePreview()"
        style="cursor:pointer;border-left:3px solid ${dayColor}">
        <span class="algo-icon">‚ú¶</span>
        <span style="color:${color};font-weight:700;font-size:11px;font-family:'Inter Tight',sans-serif">${dateStr}</span>
        ${prefLabel}${riderMatch}
      </div>`;

      // Second recommendation (alternative)
      if (recs.length > 1 && !recs[1].routesFull) {
        const alt = recs[1];
        const altDateStr = alt.date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
        const altColor = algoColor(alt.colorScore);
        const altDayColor = getDayColor(alt.dayKey.split('-')[0], alt.dayKey);
        const altPref = alt.isPreferredDay ? ' ‚òÖ' : '';
        algoStrip += `<div class="algo-strip" style="opacity:0.6;margin-top:3px;padding:4px 9px;cursor:pointer;border-left:3px solid ${altDayColor}"
          onmouseenter="showRoutePreview('${card.id}','${alt.dayKey}','${alt.truck}',${alt.insertPos})"
          onmouseleave="clearRoutePreview()">
          <span class="algo-icon" style="font-size:9px">‚óã</span>
          <span style="color:${altColor};font-weight:500;font-size:10px;font-family:'Inter Tight',sans-serif">${altDateStr}${altPref}</span>
        </div>`;
      }
    } else {
      algoStrip = `<div class="algo-strip" style="background:rgba(0,0,0,0.02)">
        <span class="algo-icon" style="opacity:0.5">‚ú¶</span>
        <span style="color:rgba(0,0,0,0.3);font-weight:500;font-size:11px;font-family:'Inter Tight',sans-serif">Calculating best route‚Ä¶</span>
      </div>`;
    }
  }

  // Expanded content with graceful fallbacks
  let expandedHtml = '';
  if (isExpanded) {
    const nameLine = card.customerName
      ? `<div class="qc-expanded-row"><span class="exp-icon">üë§</span> <strong>${card.customerName}</strong></div>`
      : `<div class="qc-expanded-row" style="color:rgba(0,0,0,0.25)"><span class="exp-icon">üë§</span> <em>No customer name</em></div>`;

    const phoneLine = card.customerPhone
      ? `<div class="qc-expanded-row"><span class="exp-icon">üìû</span> ${card.customerPhone}</div>`
      : `<div class="qc-expanded-row" style="color:rgba(180,90,40,0.5)"><span class="exp-icon">üìû</span> <em>Contact info needed ‚Äî update in Trello</em></div>`;

    const addressLine = card.address
      ? `<div class="qc-expanded-row"><span class="exp-icon">üìç</span> ${card.address}</div>`
      : `<div class="qc-expanded-row" style="color:rgba(180,90,40,0.5)"><span class="exp-icon">üìç</span> <em>Address required for scheduling</em></div>`;

    const serviceTags = [
      card.stairs && 'ü™ú Stairs',
      card.equipRemoval && 'üîß Removal',
      card.whiteGlove && 'üß§ White Glove',
      card.firstStopRequested && 'ü•á First Stop',
      card.dropoff && 'üì¶ Drop-Off',
    ].filter(Boolean);

    expandedHtml = `<div class="qc-expanded-content">
      ${nameLine}
      ${phoneLine}
      ${addressLine}
      ${card.invTotal ? `<div class="qc-expanded-row"><span class="exp-icon">üí∞</span> $${parseFloat(card.invTotal).toLocaleString()}</div>` : ''}
      ${serviceTags.length ? `<div class="qc-expanded-tags">${serviceTags.map(t => `<span class="exp-tag">${t}</span>`).join('')}</div>` : ''}
      ${card.deliveryNotes ? `<div class="qc-expanded-divider"></div><div class="qc-expanded-row" style="font-style:italic;opacity:0.7"><span class="exp-icon">üí¨</span> ${card.deliveryNotes}</div>` : ''}
      <div class="qc-expanded-divider"></div>
      <div class="qc-expanded-row" style="display:flex;align-items:center;justify-content:space-between">
        <span style="font-size:10px;color:rgba(0,0,0,0.4)">Free delivery (ride-along)</span>
        <span class="free-toggle ${card.rider ? 'active' : ''}" onclick="event.stopPropagation();toggleRider('${card.id}')">${card.rider ? '‚úì FREE' : 'Mark free'}</span>
      </div>
    </div>`;
  }

  const freeBadge = card.rider ? '<span class="free-badge">FREE</span>' : '';

  return `<div class="queue-card ${warningClass} ${isSelected ? 'selected' : ''} ${isExpanded ? 'expanded' : ''}"
    draggable="true"
    onclick="toggleExpandCard('${card.id}')"
    ondblclick="window.open('https://trello.com/c/${card.shortLink}','_blank')"
    ondragstart="dragQueueCard(event,'${card.id}')"
    ondragend="endDragQueueCard(event)">
    ${avatarHtml}
    <div class="qc-title" style="display:flex;align-items:center;gap:6px"><span>${card.name}</span>${freeBadge}</div>
    <div class="qc-flags">
      ${quadrant ? `<span class="qc-tag">${quadrant}</span>` : ''}
      <span class="qc-tag">${rsDisplay}</span>
    </div>
    ${algoStrip}
    ${expandedHtml}
  </div>`;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER RIGHT PANEL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function renderRightPanel() {
  renderRouteSheet();
}

// Day tabs removed ‚Äî center pills now control right panel via setDayFilter()

function renderRouteSheet() {
  const panel = document.getElementById('route-panel');
  const key = state.activeRightDay;

  const dates = [...getWeekDates(0), ...getWeekDates(1)];
  const dayInfo = dates.find(d => d.key === key);

  const dayColor = DAY_COLORS[dayInfo?.day] || 'var(--accent)';
  const dateLabel = dayInfo ? dayInfo.date.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' }) : key;
  const weekLabel = key.includes('W2') ? 'WK2' : 'WK1';
  const totalStops = Object.values(state.schedule[key] || {}).flat().length;

  let html = `<div class="route-day-header">
    <div class="route-day-dot" style="background:${dayColor}"></div>
    <div class="route-day-info">
      <div class="route-day-name">${dateLabel}</div>
      <div class="route-day-meta">${weekLabel} \u00b7 ${totalStops} stop${totalStops !== 1 ? 's' : ''}</div>
    </div>
  </div>`;

  const trucksToRender = ['A'];
  if (state.showTruckB || (state.schedule[key]?.B || []).length > 0) trucksToRender.push('B');
  if (state.showTruckC || (state.schedule[key]?.C || []).length > 0) trucksToRender.push('C');

  for (const truck of trucksToRender) {
    const truckKey = `${key}-${truck}`;
    const stops = state.schedule[key]?.[truck] || [];
    const isLocked = state.lockedTrucks[truckKey];

    // Get manager-assigned driver for this day+truck
    const driver = getDriverForTruck(key, truck);
    const driverName = driver ? driver.name.split(' ')[0] : null;
    const driverImg = driver ? `assets/${driver.name.split(' ')[0].toLowerCase()}.png` : '';
    const driverStatus = driver ? getDriverStatus(driver) : null;
    const isUnavailable = driverStatus && !driverStatus.available;

    const capDots = Array.from({length: MAX_STOPS}, (_, i) =>
      `<div class="cap-dot ${i < stops.length ? (stops.length > MAX_STOPS ? 'overflow' : 'filled') : ''}"></div>`
    ).join('');

    // Avatar HTML ‚Äî either assigned driver photo or placeholder
    const avatarHTML = driver
      ? `<div class="truck-driver-avatar-wrap ${isUnavailable ? 'unavailable' : ''}" onclick="event.stopPropagation();openDriverPicker('${key}','${truck}',this)" title="Click to change driver">
          <img class="truck-driver-img" src="${driverImg}" onerror="this.style.background='#2e3850';this.src=''" alt="${driverName}" />
          ${isUnavailable ? '<div class="driver-unavail-badge">!</div>' : ''}
        </div>`
      : `<div class="truck-driver-placeholder" onclick="event.stopPropagation();openDriverPicker('${key}','${truck}',this)" title="Assign a driver">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
        </div>`;

    html += `<div class="truck-section ${isUnavailable ? 'driver-warn' : ''} ${isLocked ? 'truck-locked' : ''}"
      ondragover="handleTruckDragOver(event,'${key}','${truck}')"
      ondragleave="handleTruckDragLeave(event,this)"
      ondrop="handleTruckDrop(event,'${key}','${truck}')">
      <div class="truck-header">
        ${avatarHTML}
        <div class="truck-info">
          <div class="truck-name">${driverName || '<span style="color:rgba(0,0,0,0.25);font-style:italic">No driver</span>'}</div>
          <div class="truck-label">Truck ${truck} ¬∑ ${stops.length}/${MAX_STOPS}${isLocked ? ' ¬∑ <span style="color:var(--danger)">Unavailable</span>' : ''}${isUnavailable && !isLocked ? ` ¬∑ <span style="color:var(--danger)">${driverStatus.label}</span>` : ''}</div>
        </div>
        <div class="capacity-dots">${capDots}</div>
        <button class="truck-lock-btn ${isLocked ? 'locked' : ''}" onclick="toggleTruckLock('${truckKey}','${key}','${truck}')" title="${isLocked ? 'Unlock truck' : 'Lock truck (unavailable)'}">
          ${isLocked ? 'üîí' : 'üîì'}
        </button>
      </div>`;

    if (stops.length === 0) {
      html += `<div class="stops-list">
        <div class="truck-empty">${isLocked ? 'Truck unavailable ‚Äî unlock to open' : 'No stops ‚Äî drag a card here or use Schedule'}</div>
      </div>`;
    } else {
      html += `<div class="stops-list">
        <div class="route-endpoint"><span class="endpoint-icon">üè≠</span> Fruitland Warehouse</div>`;

      stops.forEach((stop, i) => {
        const isStaged = !stop.committed;
        const isCommitted = !!stop.committed;
        const flags = [
          stop.firstStopApproved && '<span class="stop-flag flag-first">1st</span>',
          stop.whiteGlove && '<span class="stop-flag flag-wg">WG</span>',
          stop.equipRemoval && '<span class="stop-flag flag-remove">RM</span>',
        ].filter(Boolean).join('');

        const stopDayColor = getDayColor(key.split('-')[0], key);
        html += `<div class="stop-item ${isStaged ? 'staged' : ''} ${isCommitted ? 'committed' : ''}" draggable="true"
          ${isStaged ? `style="--day-color:${stopDayColor}"` : ''}
          ondragstart="dragStop(event,'${key}','${truck}',${i})"
          ondragover="event.preventDefault();this.style.background='rgba(240,201,58,0.06)'"
          ondragleave="this.style.background=''"
          ondrop="dropStop(event,'${key}','${truck}',${i});this.style.background=''">
          <div class="stop-num" title="Drag to reorder">‚†ø ${i+1}</div>
          <div class="stop-content">
            <div class="stop-name">${stop.cardName || stop.name}</div>
            <div class="stop-meta">
              ${stop.address ? `<span>${stop.address.split(',')[0]}</span>` : ''}
              ${flags}
            </div>
          </div>
          <div class="stop-actions">
            ${isStaged ? `<button class="stop-commit-btn" onclick="event.stopPropagation();commitSingleCard('${key}','${truck}',${i})" title="Commit to Trello">Commit</button>` : ''}
            ${isCommitted ? '<span style="font-size:10px;color:var(--success);font-weight:600;font-family:Inter Tight,sans-serif">‚úì</span>' : ''}
            <button class="stop-btn" onclick="editStop('${key}','${truck}',${i})" title="Edit">‚úé</button>
            ${isCommitted ? `<button class="stop-btn remove" onclick="removeStop('${key}','${truck}',${i})" title="Remove (will undo Trello)">‚úï</button>` : ''}
          </div>
          ${isStaged && stop.stagedAt ? `<div class="staged-meta"><span class="staged-by">${stop.stagedBy || ''}</span><span class="staged-time">Staged ${new Date(stop.stagedAt).toLocaleTimeString('en-US',{hour:'numeric',minute:'2-digit'})}</span></div>` : ''}
        </div>`;
      });

      html += `<div class="route-endpoint"><span class="endpoint-icon">üè†</span> Charlie's HQ</div>
      </div>`;
    }

    html += `</div>`;
  }

  panel.innerHTML = html;

  // Restore truck B/C toggle button visibility
  const btnB = document.getElementById('truck-b-btn');
  const btnC = document.getElementById('truck-c-btn');
  if (state.showTruckB) {
    if (btnB) btnB.style.display = 'none';
    if (btnC) btnC.style.display = 'block';
    if (btnC) btnC.textContent = state.showTruckC ? '‚àí Remove Truck C' : '+ Add Truck C';
  } else {
    if (btnB) btnB.style.display = 'block';
    if (btnC) btnC.style.display = 'none';
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INTERACTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function selectCard(cardId) {
  const card = state.queueCards.find(c => c.id === cardId);
  if (!card) return;
  state.selectedCard = card;
  renderQueue();

  // Animate the map dot for this card
  state.unscheduledMarkers.forEach((m, i) => {
    const c = state.queueCards[i];
    if (!c?.coords) return;
    const el = m.getElement();
    if (!el) return;
    const dot = el.querySelector('.unscheduled-pin');
    if (!dot) return;
    if (c.id === cardId) {
      dot.classList.add('selected');
      map.panTo([c.coords.lat, c.coords.lng], { animate: true, duration: 0.5 });
    } else {
      dot.classList.remove('selected');
    }
  });
}

function toggleRider(cardId) {
  const card = state.queueCards.find(c => c.id === cardId);
  if (!card) return;
  card.rider = !card.rider;
  renderQueue();
  if (card.rider) {
    showToast(`üè∑ ${card.name.split(' ').slice(0,3).join(' ')}‚Ä¶ flagged as rider ‚Äî waiting for in-route match`, 'info');
  } else {
    showToast(`Rider flag removed`, 'info');
  }
}

function toggleExpandCard(cardId) {
  const card = state.queueCards.find(c => c.id === cardId);
  if (!card) return;

  // Toggle expanded state
  state.expandedCard = state.expandedCard === cardId ? null : cardId;
  state.selectedCard = card;

  // Pulse the map dot
  state.unscheduledMarkers.forEach((m, i) => {
    const c = state.queueCards[i];
    if (!c?.coords) return;
    const el = m.getElement();
    if (!el) return;
    const dot = el.querySelector('.unscheduled-pin');
    if (!dot) return;
    if (c.id === cardId) {
      dot.classList.add('selected');
      map.panTo([c.coords.lat, c.coords.lng], { animate: true, duration: 0.5 });
    } else {
      dot.classList.remove('selected');
    }
  });

  renderQueue();
  updateRouteAnimation();
}

function dragQueueCard(e, cardId) {
  e.dataTransfer.setData('text/plain', cardId);
  e.dataTransfer.effectAllowed = 'move';
  e.target.classList.add('dragging');
  state._draggingCardId = cardId;
}

function endDragQueueCard(e) {
  e.target.classList.remove('dragging');
  // Clean up any lingering drop-hover states
  document.querySelectorAll('.truck-section.drop-hover').forEach(el => el.classList.remove('drop-hover'));
  state._draggingCardId = null;
}

// ‚îÄ‚îÄ DROP ZONE HANDLERS ‚îÄ‚îÄ
function handleTruckDragOver(e, dayKey, truck) {
  e.preventDefault();
  const section = e.currentTarget;
  const truckKey = `${dayKey}-${truck}`;

  // Accept stop-to-stop drags (cross-truck reorder)
  if (dragData) {
    // Reject: locked truck
    if (state.lockedTrucks?.[truckKey] || state[`lock-${dayKey}-${truck}`]) {
      section.classList.add('drop-reject');
      section.classList.remove('drop-hover');
      e.dataTransfer.dropEffect = 'none';
      return;
    }
    // Reject: same truck (handled by stop-level drop)
    if (dragData.dayKey === dayKey && dragData.truck === truck) return;
    // Visual warning for full truck (but still allow drop for overflow)
    const stops = state.schedule[dayKey]?.[truck] || [];
    if (stops.length >= MAX_STOPS) {
      section.classList.add('drop-hover');
      section.style.opacity = '0.7'; // dimmed to indicate overflow
      return;
    }
    section.classList.add('drop-hover');
    section.classList.remove('drop-reject');
    e.dataTransfer.dropEffect = 'move';
    return;
  }

  // Queue card drag
  const cardId = state._draggingCardId;
  if (!cardId) return;

  const card = state.queueCards.find(c => c.id === cardId);

  // Reject: no coords
  if (!card?.coords) {
    section.classList.add('drop-reject');
    section.classList.remove('drop-hover');
    e.dataTransfer.dropEffect = 'none';
    return;
  }

  // Reject: locked truck
  if (state.lockedTrucks?.[truckKey] || state[`lock-${dayKey}-${truck}`]) {
    section.classList.add('drop-reject');
    section.classList.remove('drop-hover');
    e.dataTransfer.dropEffect = 'none';
    return;
  }

  // Accept
  section.classList.add('drop-hover');
  section.classList.remove('drop-reject');
  e.dataTransfer.dropEffect = 'move';
}

function handleTruckDragLeave(e, el) {
  // Only remove if leaving the truck-section (not entering a child)
  if (!el.contains(e.relatedTarget)) {
    el.classList.remove('drop-hover');
    el.classList.remove('drop-reject');
  }
}

function handleTruckDrop(e, dayKey, truck, insertAtIdx) {
  e.preventDefault();
  e.stopPropagation();

  const section = e.currentTarget || e.target.closest('.truck-section');
  if (section) {
    section.classList.remove('drop-hover');
    section.classList.remove('drop-reject');
  }

  // Case 1: Cross-truck stop reorder (dragData set by dragStop)
  if (dragData) {
    const { dayKey: fromDay, truck: fromTruck, idx: fromIdx } = dragData;
    if (fromDay === dayKey && fromTruck === truck) { dragData = null; return; } // same truck, ignore

    const fromStops = state.schedule[fromDay]?.[fromTruck];
    const toStops = state.schedule[dayKey]?.[truck] || [];
    if (!fromStops) { dragData = null; return; }

    const truckKey = `${dayKey}-${truck}`;
    if (state.lockedTrucks?.[truckKey] || state[`lock-${dayKey}-${truck}`]) {
      showToast(`üîí ${truck} is locked`, 'warning');
      dragData = null;
      return;
    }
    if (toStops.length >= MAX_STOPS) {
      showToast(`‚ö† Truck ${truck} is over capacity (${toStops.length + 1}/${MAX_STOPS})`, 'warning');
    }

    if (!state.schedule[dayKey]) state.schedule[dayKey] = {};
    if (!state.schedule[dayKey][truck]) state.schedule[dayKey][truck] = [];

    const [moved] = fromStops.splice(fromIdx, 1);
    const toPos = typeof insertAtIdx === 'number' ? insertAtIdx : state.schedule[dayKey][truck].length;
    state.schedule[dayKey][truck].splice(toPos, 0, moved);
    dragData = null;
    renderRightPanel();
    renderMap();

    const toLabel = truck.replace('truck','Truck ').replace('a','A').replace('b','B').replace('c','C');
    showToast(`‚Üî Moved to ${toLabel}, Stop ${toPos + 1}`, 'info');
    return;
  }

  // Case 2: Queue card drop
  const cardId = e.dataTransfer.getData('text/plain');
  if (!cardId) return;

  const card = state.queueCards.find(c => c.id === cardId);
  if (!card) return;

  const truckKey = `${dayKey}-${truck}`;

  // Reject: no address
  if (!card.coords) {
    showToast('‚ö† Address required ‚Äî cannot schedule this card', 'error');
    return;
  }

  // Reject: locked
  if (state.lockedTrucks?.[truckKey] || state[`lock-${dayKey}-${truck}`]) {
    showToast('üîí Truck is locked ‚Äî unlock to add stops', 'error');
    return;
  }

  // Reject: full (4 stops) and not within overflow radius
  const stops = state.schedule[dayKey]?.[truck] || [];
  if (stops.length >= MAX_STOPS) {
    const minDist = stops.reduce((min, s) => Math.min(min, distanceMiles(card.coords, s.coords)), Infinity);
    if (minDist > OVERFLOW_RADIUS_MILES) {
      showToast(`Truck ${truck} is full (${MAX_STOPS} stops) ‚Äî card too far for overflow`, 'error');
      return;
    }
    showToast(`‚ö† Over capacity (${stops.length + 1}/${MAX_STOPS}) ‚Äî card is nearby, allowed`, 'warning');
  }

  // Find best insert position using algo (or use specified position)
  const insertPos = typeof insertAtIdx === 'number' ? insertAtIdx : bestInsertPosition(stops, card.coords);

  // Build stop object from card (staged, not committed)
  const newStop = {
    id: card.id,
    cardId: card.id,
    shortLink: card.shortLink,
    name: card.name,
    cardName: card.name,
    address: card.address,
    coords: card.coords,
    quadrant: card.quadrant,
    invTotal: card.invTotal,
    customerName: card.customerName,
    customerPhone: card.customerPhone,
    firstStopRequested: card.firstStopRequested,
    firstStopApproved: card.firstStopRequested,
    whiteGlove: card.whiteGlove,
    equipRemoval: card.equipRemoval,
    stairs: card.stairs,
    dropoff: card.dropoff,
    deliveryNotes: card.deliveryNotes,
    committed: false,
    stagedAt: Date.now(),
    stagedBy: state.currentUser || '',
  };

  // Insert into schedule
  if (!state.schedule[dayKey]) state.schedule[dayKey] = {};
  if (!state.schedule[dayKey][truck]) state.schedule[dayKey][truck] = [];
  state.schedule[dayKey][truck].splice(insertPos, 0, newStop);

  // Remove from pending queue
  state.queueCards = state.queueCards.filter(c => c.id !== cardId);

  // Re-render everything
  renderQueue();
  renderRightPanel();
  renderMap();

  showToast(`üì¶ ${card.name.split(' ').slice(0,3).join(' ')}‚Ä¶ ‚Üí Truck ${truck}, Stop ${insertPos + 1}`, 'info');
}

// ‚îÄ‚îÄ PER-CARD COMMIT TO TRELLO ‚îÄ‚îÄ
async function commitSingleCard(dayKey, truck, stopIndex) {
  const stops = state.schedule[dayKey]?.[truck];
  if (!stops || !stops[stopIndex]) return;

  const stop = stops[stopIndex];
  if (stop.committed) {
    showToast('Already committed', 'info');
    return;
  }

  // Determine scheduled date
  const allDays = [...getWeekDates(0), ...getWeekDates(1)];
  const dayInfo = allDays.find(d => d.key === dayKey);
  if (!dayInfo) { showToast('Could not determine date', 'error'); return; }

  // Due date = scheduled day at 5:00 PM Pacific
  const dueDate = new Date(dayInfo.date);
  const isDST = dueDate.getMonth() >= 2 && dueDate.getMonth() <= 10; // rough DST
  dueDate.setHours(17, 0, 0, 0);
  const offset = isDST ? 7 : 8; // PDT = UTC-7, PST = UTC-8
  const utcDue = new Date(dueDate.getTime() + offset * 3600000);

  try {
    showToast('Committing to Trello‚Ä¶', 'info');

    // 1. Set due date
    await trello(`/cards/${stop.cardId}`, 'PUT', { due: utcDue.toISOString() });

    // 2. Set OT custom field to true
    const otField = state.customFields?.find(f => f.name === 'OT');
    if (otField) {
      await trello(`/cards/${stop.cardId}/customField/${otField.id}/item`, 'PUT', {
        value: { checked: 'true' }
      });
    }

    // 3. Add comment with scheduling info
    const comment = `üì¶ Scheduled: ${dayInfo.day} ${dayInfo.date.toLocaleDateString('en-US', {month:'short',day:'numeric'})} ¬∑ Truck ${truck} ¬∑ Stop ${stopIndex + 1}\nüïê Due: 5:00 PM Pacific\nüìç Via CF Dispatch`;
    await trello(`/cards/${stop.cardId}/actions/comments`, 'POST', { text: comment });

    // 4. Move card to salesperson's shipper list
    // Find the card owner's shipper list (e.g., "Shipper - William")
    if (stop.cardId) {
      const cardData = await trello(`/cards/${stop.cardId}?fields=idMembers`);
      if (cardData.idMembers?.length > 0) {
        const memberId = cardData.idMembers[0];
        const member = await trello(`/members/${memberId}?fields=fullName`);
        const firstName = member.fullName?.split(' ')[0] || '';
        if (firstName) {
          const lists = await trello(`/boards/${BOARD_ID}/lists?fields=name`);
          const shipperList = lists.find(l => l.name.toLowerCase().includes('shipper') && l.name.toLowerCase().includes(firstName.toLowerCase()));
          if (shipperList) {
            await trello(`/cards/${stop.cardId}`, 'PUT', { idList: shipperList.id });
          }
        }
      }
    }

    // Mark as committed in local state
    stop.committed = true;

    renderRightPanel();
    renderMap();
    showToast(`‚úÖ ${stop.cardName || stop.name} committed!`, 'success');

  } catch (err) {
    console.error('Commit failed:', err);
    showToast('‚ùå Commit failed ‚Äî check console', 'error');
  }
}

function scheduleCard(cardId) {
  const card = state.queueCards.find(c => c.id === cardId);
  if (!card || !card.coords) return;

  state.selectedCard = card;

  // Run recommendation
  const suggestion = recommend(card);
  state.pendingSuggestion = suggestion ? { ...suggestion, card } : null;

  if (suggestion) {
    showSuggestion(card, suggestion);
  } else {
    openAssignModal(card, false);
  }
}

function showSuggestion(card, sug) {
  const banner = document.getElementById('suggestion-banner');
  const detail = document.getElementById('sug-detail');
  const meta = document.getElementById('sug-meta');

  const overflowWarn = sug.overflow ? ' ‚ö†Ô∏è Over soft cap' : '';
  detail.textContent = `${sug.day} ¬∑ Truck ${sug.truck} ¬∑ Stop ${sug.insertPos + 1}${overflowWarn}`;
  meta.textContent = `Closest stop: ${sug.minDist.toFixed(1)} mi away`;

  banner.classList.add('visible');
  renderMap(); // preview pulse could be added here
}

function dismissSuggestion() {
  document.getElementById('suggestion-banner').classList.remove('visible');
  state.pendingSuggestion = null;
}

function confirmSuggestion() {
  const sug = state.pendingSuggestion;
  if (!sug) return;
  applyAssignment(sug.card, sug.dayKey, sug.truck, sug.insertPos);
  dismissSuggestion();
}

function openAssignModal(card, prefilled) {
  const c = card || state.selectedCard;
  if (!c) return;

  document.getElementById('modal-title').textContent = 'Schedule Stop';
  document.getElementById('modal-sub').textContent = c.name;

  // First stop section
  const fsSection = document.getElementById('first-stop-section');
  if (c.firstStopRequested) {
    fsSection.style.display = 'block';
    setFirstStopStatus(null); // reset
  } else {
    fsSection.style.display = 'none';
  }

  // Populate day dropdown
  const daySelect = document.getElementById('modal-day');
  const allDays = [...getWeekDates(0), ...getWeekDates(1)];
  daySelect.innerHTML = '<option value="">Select day...</option>' +
    allDays.map(({ day, date, key }) =>
      `<option value="${key}">${day} ${date.toLocaleDateString('en-US',{month:'short',day:'numeric'})}</option>`
    ).join('');

  // Pre-fill from suggestion
  if (prefilled && state.pendingSuggestion) {
    const sug = state.pendingSuggestion;
    daySelect.value = sug.dayKey;
    document.getElementById('modal-truck').value = sug.truck;
  }

  // Populate driver dropdown
  const driverSelect = document.getElementById('modal-driver');
  driverSelect.innerHTML = '<option value="">Select driver...</option>' +
    state.drivers.map(d => {
      const status = getDriverStatus(d);
      const label = status.available ? d.name.split(' ')[0] : `${d.name.split(' ')[0]} (${status.label})`;
      return `<option value="${d.id}" ${!status.available ? 'disabled' : ''}>${label}</option>`;
    }).join('');

  document.getElementById('assign-modal').classList.add('open');
}

let firstStopModalStatus = null;

function setFirstStopStatus(status) {
  firstStopModalStatus = status;
  document.getElementById('fs-approve').className = `fs-btn ${status === 'approved' ? 'selected' : ''}`;
  document.getElementById('fs-revoke').className = `fs-btn revoke ${status === 'revoked' ? 'selected' : ''}`;
}

function confirmAssign() {
  const card = state.selectedCard;
  if (!card) return;

  const dayKey = document.getElementById('modal-day').value;
  const truck = document.getElementById('modal-truck').value;
  const stopPos = document.getElementById('modal-stop').value;
  const driverId = document.getElementById('modal-driver').value;

  if (!dayKey || !truck) { showToast('Please select a day and truck', 'error'); return; }

  // Assign driver to truck for this day (if selected)
  if (driverId && dayKey) {
    state.truckDrivers[`${dayKey}-${truck}`] = driverId;
    saveTruckDrivers();
  }

  const pos = stopPos === 'auto' ? bestInsertPosition(state.schedule[dayKey]?.[truck] || [], card.coords) : parseInt(stopPos);

  applyAssignment(card, dayKey, truck, pos, firstStopModalStatus);
  closeModal('assign-modal');
}

function applyAssignment(card, dayKey, truck, pos, firstStopStatus = null) {
  if (!state.schedule[dayKey]) state.schedule[dayKey] = {};
  if (!state.schedule[dayKey][truck]) state.schedule[dayKey][truck] = [];

  const stop = {
    ...card,
    cardName: card.name,
    dayKey,
    truck,
    firstStopApproved: firstStopStatus === 'approved',
    firstStopRevoked: firstStopStatus === 'revoked',
    pendingCommit: true,
  };

  // Handle first stop lock
  if (firstStopStatus === 'approved') {
    state.schedule[dayKey][truck].unshift(stop);
  } else {
    state.schedule[dayKey][truck].splice(pos, 0, stop);
  }

  // Reoptimize order (unless first stop is locked)
  reoptimizeTruck(dayKey, truck);

  // Remove from queue
  state.queueCards = state.queueCards.filter(c => c.id !== card.id);
  state.selectedCard = null;

  // Update right panel active day
  state.activeRightDay = dayKey;

  showToast(`Scheduled: ${card.name} ‚Üí ${dayKey} Truck ${truck}`, 'success');
  renderQueue();
  renderRightPanel();
  renderMap();
  const commitAllBtn = document.getElementById('commit-all-btn');
  if (commitAllBtn) commitAllBtn.style.display = 'block';
}

function reoptimizeTruck(dayKey, truck) {
  const stops = state.schedule[dayKey]?.[truck];
  if (!stops || stops.length <= 1) return;

  // Find locked first stop
  const firstIdx = stops.findIndex(s => s.firstStopApproved);

  if (firstIdx >= 0) {
    const first = stops[firstIdx];
    const rest = stops.filter((_, i) => i !== firstIdx);
    // Optimize rest
    const optimized = optimizeOrder(rest);
    state.schedule[dayKey][truck] = [first, ...optimized];
  } else {
    state.schedule[dayKey][truck] = optimizeOrder(stops);
  }
}

function optimizeOrder(stops) {
  if (stops.length <= 1) return stops;
  // Brute force for up to 6 stops
  const perms = permutations(stops);
  let best = stops, bestDist = loopDistance(stops.map(s => ({ coords: s.coords })));
  for (const perm of perms) {
    const d = loopDistance(perm.map(s => ({ coords: s.coords })));
    if (d < bestDist) { bestDist = d; best = perm; }
  }
  return best;
}

function permutations(arr) {
  if (arr.length <= 1) return [arr];
  return arr.flatMap((item, i) =>
    permutations([...arr.slice(0,i), ...arr.slice(i+1)]).map(p => [item, ...p])
  );
}

function removeStop(dayKey, truck, idx) {
  const stop = state.schedule[dayKey]?.[truck]?.[idx];
  if (!stop) return;

  // Staged (uncommitted) ‚Äî instant removal, no dialog
  if (!stop.committed) {
    state.schedule[dayKey][truck].splice(idx, 1);
    state.queueCards.unshift({
      id: stop.cardId || stop.id,
      shortLink: stop.shortLink,
      name: stop.cardName || stop.name,
      address: stop.address,
      coords: stop.coords,
      quadrant: stop.quadrant,
      invTotal: stop.invTotal,
      customerName: stop.customerName,
      customerPhone: stop.customerPhone,
      firstStopRequested: stop.firstStopRequested,
      whiteGlove: stop.whiteGlove,
      equipRemoval: stop.equipRemoval,
      stairs: stop.stairs,
      dropoff: stop.dropoff,
      deliveryNotes: stop.deliveryNotes,
      rider: stop.rider,
    });
    renderQueue();
    renderRightPanel();
    renderMap();
    showToast(`‚Ü© ${(stop.cardName || stop.name).split(' ').slice(0,3).join(' ')}‚Ä¶ returned to queue`, 'info');
    return;
  }

  // Committed ‚Äî confirm dialog, undo Trello changes
  showConfirm(
    'üóëÔ∏è',
    'Un-commit from schedule?',
    'This will undo the Trello changes (clear due date, OT field) and return the card to the queue.',
    async () => {
      try {
        await trello(`/cards/${stop.id}`, 'PUT', { due: null });
        await trello(`/cards/${stop.id}/customField/${CUSTOM_FIELDS.OT}/item`, 'PUT', { value: { checked: 'false' } });
        await trello(`/cards/${stop.id}/actions/comments`, 'POST', { text: 'üîÑ Removed from schedule via CF Dispatch' });

        state.schedule[dayKey][truck].splice(idx, 1);
        reoptimizeTruck(dayKey, truck);
        state.queueCards.unshift({ ...stop, committed: false });

        showToast(`${stop.cardName || stop.name} un-committed and returned to queue`, 'info');
        renderQueue();
        renderRightPanel();
        renderMap();
      } catch (e) {
        showToast('Failed to unschedule in Trello ‚Äî try again', 'error');
      }
    }
  );
}

function editStop(dayKey, truck, idx) {
  const stop = state.schedule[dayKey]?.[truck]?.[idx];
  if (!stop) return;
  state.selectedCard = stop;
  openAssignModal(stop, false);
}

let dragData = null;

function dragStop(e, dayKey, truck, idx) {
  dragData = { dayKey, truck, idx };
  e.dataTransfer.effectAllowed = 'move';
}

function dropStop(e, dayKey, truck, toIdx) {
  e.preventDefault();
  e.stopPropagation(); // Don't bubble to truck-section drop handler

  // Case 1: Queue card dropped onto a specific stop position
  const cardId = e.dataTransfer.getData('text/plain');
  if (cardId && !dragData) {
    // Delegate to truck drop handler with specific insert position
    handleTruckDrop(e, dayKey.replace('schedule-',''), truck, toIdx);
    return;
  }

  if (!dragData) return;
  const { dayKey: fromDay, truck: fromTruck, idx: fromIdx } = dragData;

  // Same truck reorder
  if (fromDay === dayKey && fromTruck === truck) {
    if (fromIdx === toIdx) { dragData = null; return; }
    const stops = state.schedule[dayKey][truck];
    const [moved] = stops.splice(fromIdx, 1);
    stops.splice(toIdx, 0, moved);
    dragData = null;
    renderRightPanel();
    renderMap();
    showToast('Stop order updated', 'info');
    return;
  }

  // Cross-truck move (same day or different day)
  const fromStops = state.schedule[fromDay]?.[fromTruck];
  const toStops = state.schedule[dayKey]?.[truck];
  if (!fromStops || !toStops) { dragData = null; return; }

  // Check capacity on target truck
  if (toStops.length >= 4) {
    showToast(`‚ö† ${truck} is full (4 stops max)`, 'warning');
    dragData = null;
    return;
  }

  // Check if target truck is locked
  const lockKey = `lock-${dayKey}-${truck}`;
  if (state[lockKey]) {
    showToast(`üîí ${truck} is locked`, 'warning');
    dragData = null;
    return;
  }

  const [moved] = fromStops.splice(fromIdx, 1);
  toStops.splice(toIdx, 0, moved);
  dragData = null;
  renderRightPanel();
  renderMap();

  const fromLabel = fromTruck.replace('truck','Truck ').toUpperCase().replace('TRUCK ','Truck ');
  const toLabel = truck.replace('truck','Truck ').toUpperCase().replace('TRUCK ','Truck ');
  if (moved.committed) {
    showToast(`‚ö† Committed stop moved to ${toLabel} ‚Äî Trello may need updating`, 'warning');
  } else {
    showToast(`‚Üî Moved to ${toLabel}, Stop ${toIdx + 1}`, 'info');
  }
}

// ‚îÄ‚îÄ DRAG STOP BACK TO QUEUE (UN-SCHEDULE) ‚îÄ‚îÄ
function handleQueueDragOver(e) {
  if (!dragData) return; // only accept stop drags, not queue card drags
  e.preventDefault();
  e.currentTarget.style.outline = '2px dashed rgba(240,201,58,0.5)';
  e.currentTarget.style.outlineOffset = '-2px';
  e.dataTransfer.dropEffect = 'move';
}

function handleQueueDragLeave(e) {
  if (!e.currentTarget.contains(e.relatedTarget)) {
    e.currentTarget.style.outline = '';
    e.currentTarget.style.outlineOffset = '';
  }
}

function handleQueueDrop(e) {
  e.preventDefault();
  e.currentTarget.style.outline = '';
  e.currentTarget.style.outlineOffset = '';

  if (!dragData) return;
  const { dayKey, truck, idx } = dragData;
  const stops = state.schedule[dayKey]?.[truck];
  if (!stops || !stops[idx]) { dragData = null; return; }

  const stop = stops[idx];

  // Don't allow un-scheduling committed stops
  if (stop.committed) {
    showToast('‚ö† Already committed to Trello ‚Äî cannot un-schedule', 'warning');
    dragData = null;
    return;
  }

  // Remove from schedule
  stops.splice(idx, 1);

  // Rebuild as queue card and add back
  const queueCard = {
    id: stop.cardId || stop.id,
    shortLink: stop.shortLink,
    name: stop.cardName || stop.name,
    address: stop.address,
    coords: stop.coords,
    quadrant: stop.quadrant,
    invTotal: stop.invTotal,
    customerName: stop.customerName,
    customerPhone: stop.customerPhone,
    firstStopRequested: stop.firstStopRequested,
    whiteGlove: stop.whiteGlove,
    equipRemoval: stop.equipRemoval,
    stairs: stop.stairs,
    dropoff: stop.dropoff,
    deliveryNotes: stop.deliveryNotes,
  };
  state.queueCards.push(queueCard);

  dragData = null;
  renderQueue();
  renderRightPanel();
  renderMap();
  showToast(`‚Ü© ${(stop.cardName || stop.name).split(' ').slice(0,3).join(' ')}‚Ä¶ returned to queue`, 'info');
}

function toggleTruckB() {
  state.showTruckB = !state.showTruckB;
  const btnB = document.getElementById('truck-b-btn');
  const btnC = document.getElementById('truck-c-btn');
  if (state.showTruckB) {
    if (btnB) btnB.style.display = 'none';
    if (btnC) btnC.style.display = 'block';
  } else {
    if (btnB) btnB.style.display = 'block';
    if (btnC) btnC.style.display = 'none';
    state.showTruckC = false; // removing B also removes C
  }
  renderRightPanel();
}

function toggleTruckC() {
  state.showTruckC = !state.showTruckC;
  const btn = document.getElementById('truck-c-btn');
  if (btn) btn.textContent = state.showTruckC ? '‚àí Remove Truck C' : '+ Add Truck C';
  renderRightPanel();
}

function toggleTruckLock(truckKey, dayKey, truck) {
  const isCurrentlyLocked = state.lockedTrucks[truckKey];

  if (isCurrentlyLocked) {
    // UNLOCK ‚Äî simple
    state.lockedTrucks[truckKey] = false;
    saveLockState();
    renderRightPanel();
    renderMap();
    showToast('üîì Truck unlocked ‚Äî available for scheduling', 'info');
    return;
  }

  // LOCK ‚Äî check if truck has stops
  const stops = state.schedule[dayKey]?.[truck] || [];

  if (stops.length === 0) {
    // Empty truck ‚Äî lock immediately
    state.lockedTrucks[truckKey] = true;
    saveLockState();
    renderRightPanel();
    renderMap();
    showToast('üîí Truck locked ‚Äî unavailable', 'info');
    return;
  }

  // Truck has stops ‚Äî confirm dialog
  const committedCount = stops.filter(s => s.committed).length;
  const totalCount = stops.length;
  const msg = committedCount > 0
    ? `${totalCount} stop${totalCount > 1 ? 's' : ''} (${committedCount} committed) will return to Pending. Trello changes will be undone.`
    : `${totalCount} stop${totalCount > 1 ? 's' : ''} will return to Pending.`;

  showConfirm(
    'üîí',
    `Lock Truck ${truck}?`,
    msg,
    async () => {
      // Bounce all stops back to queue
      const stopsToReturn = [...stops];
      state.schedule[dayKey][truck] = [];

      for (const stop of stopsToReturn) {
        if (stop.committed) {
          // Committed card ‚Äî undo Trello changes
          try {
            // 1. Get card member username for @mention
            let memberMention = '';
            try {
              const members = await trello(`/cards/${stop.id}/members`);
              if (members && members.length > 0) {
                memberMention = ` @${members[0].username}`;
              }
            } catch(e) { /* no member found, skip mention */ }

            // 2. Move to Requested for Schedule FIRST (before clearing due date to prevent Butler conflict)
            const lists = await trello(`/boards/${BOARD_ID}/lists?fields=id,name`);
            const rsList = lists.find(l => l.name.toLowerCase().includes('requested for schedule'));
            if (rsList) {
              await trello(`/cards/${stop.id}`, 'PUT', { idList: rsList.id });
            }

            // 3. Clear due date
            await trello(`/cards/${stop.id}`, 'PUT', { due: null });

            // 4. Clear OT field
            await trello(`/cards/${stop.id}/customField/${CUSTOM_FIELDS.OT}/item`, 'PUT', { value: { checked: 'false' } });

            // 5. Post comment with @mention for Butler ‚Üí Slack notification
            await trello(`/cards/${stop.id}/actions/comments`, 'POST', {
              text: `üîí Truck unavailable ‚Äî returned to Pending via CF Dispatch${memberMention}`
            });
          } catch(e) {
            console.error('Failed to undo Trello for', stop.name, e);
          }
        }

        // Return card to queue
        state.queueCards.push({
          id: stop.cardId || stop.id,
          shortLink: stop.shortLink,
          name: stop.cardName || stop.name,
          address: stop.address,
          coords: stop.coords,
          quadrant: stop.quadrant,
          invTotal: stop.invTotal,
          customerName: stop.customerName,
          customerPhone: stop.customerPhone,
          firstStopRequested: stop.firstStopRequested,
          whiteGlove: stop.whiteGlove,
          equipRemoval: stop.equipRemoval,
          stairs: stop.stairs,
          dropoff: stop.dropoff,
          deliveryNotes: stop.deliveryNotes,
          rider: stop.rider,
          rsValue: stop.rsValue,
        });
      }

      // Lock the truck
      state.lockedTrucks[truckKey] = true;
      saveLockState();

      renderQueue();
      renderRightPanel();
      renderMap();

      showToast(`üîí Truck ${truck} locked ‚Äî ${totalCount} stop${totalCount > 1 ? 's' : ''} returned to Pending`, 'info');
    }
  );
}

// ‚îÄ‚îÄ LOCK STATE PERSISTENCE ‚îÄ‚îÄ
function saveLockState() {
  try {
    localStorage.setItem('cf-dispatch-locks', JSON.stringify(state.lockedTrucks));
  } catch(e) { /* localStorage unavailable */ }
}

function loadLockState() {
  try {
    const saved = localStorage.getItem('cf-dispatch-locks');
    if (saved) {
      state.lockedTrucks = JSON.parse(saved);
    }
  } catch(e) { /* localStorage unavailable */ }
}

// ‚îÄ‚îÄ QUEUE SORT HELPER ‚îÄ‚îÄ
// Note: renderQueue() already sorts by RS date ‚Üí creation date. No separate sort needed.

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// DRIVER PICKER (inline popover)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let activeDriverPicker = null;

function openDriverPicker(dayKey, truck, anchorEl) {
  // Close any existing picker
  closeDriverPicker();

  const truckKey = `${dayKey}-${truck}`;
  const currentDriverId = state.truckDrivers[truckKey] || null;

  const picker = document.createElement('div');
  picker.className = 'driver-picker';
  picker.id = 'active-driver-picker';

  // Position near the anchor
  const rect = anchorEl.getBoundingClientRect();
  picker.style.top = `${rect.bottom + 6}px`;
  picker.style.left = `${rect.left}px`;

  let html = `<div class="driver-picker-title">Assign driver ¬∑ Truck ${truck}</div>`;

  // "Unassign" option if currently assigned
  if (currentDriverId) {
    html += `<div class="driver-option unassign" onclick="assignDriverToTruck('${dayKey}','${truck}',null)">
      <div class="driver-placeholder-small">‚úï</div>
      <div class="driver-option-info">
        <div class="driver-option-name" style="color:rgba(0,0,0,0.42)">Remove driver</div>
      </div>
    </div>`;
  }

  state.drivers.forEach(d => {
    const status = getDriverStatus(d);
    const firstName = d.name.split(' ')[0];
    const imgSrc = `assets/${firstName.toLowerCase()}.png`;
    const isSelected = d.id === currentDriverId;
    const statusClass = !status.available ? 'away' : (status.label ? 'soon' : '');

    // Check if this driver is already assigned to another truck on the same day
    let alreadyAssigned = null;
    for (const t of ['A','B','C']) {
      if (t === truck) continue;
      if (state.truckDrivers[`${dayKey}-${t}`] === d.id) {
        alreadyAssigned = t;
        break;
      }
    }

    html += `<div class="driver-option ${isSelected ? 'selected' : ''} ${!status.available ? 'unavailable-option' : ''}" onclick="assignDriverToTruck('${dayKey}','${truck}','${d.id}')">
      <img src="${imgSrc}" onerror="this.style.background='#2e3850';this.src=''" alt="${firstName}" />
      <div class="driver-option-info">
        <div class="driver-option-name">${firstName}${isSelected ? ' ‚úì' : ''}</div>
        <div class="driver-option-status ${statusClass}">
          ${!status.available ? status.label : (alreadyAssigned ? `on Truck ${alreadyAssigned}` : (status.label || 'Available'))}
        </div>
      </div>
    </div>`;
  });

  picker.innerHTML = html;
  document.body.appendChild(picker);
  activeDriverPicker = picker;

  // Close on outside click
  setTimeout(() => {
    document.addEventListener('click', closeDriverPickerOutside);
  }, 10);
}

function closeDriverPickerOutside(e) {
  const picker = document.getElementById('active-driver-picker');
  if (picker && !picker.contains(e.target)) {
    closeDriverPicker();
  }
}

function closeDriverPicker() {
  const picker = document.getElementById('active-driver-picker');
  if (picker) picker.remove();
  activeDriverPicker = null;
  document.removeEventListener('click', closeDriverPickerOutside);
}

function assignDriverToTruck(dayKey, truck, driverId) {
  const truckKey = `${dayKey}-${truck}`;

  if (driverId === null || driverId === 'null') {
    delete state.truckDrivers[truckKey];
    showToast(`Truck ${truck} driver removed`, 'info');
  } else {
    // Check if driver is unavailable ‚Äî warn but still allow
    const driver = state.drivers.find(d => d.id === driverId);
    const status = driver ? getDriverStatus(driver) : null;

    // If driver is on another truck same day, swap them
    for (const t of ['A','B','C']) {
      if (t === truck) continue;
      if (state.truckDrivers[`${dayKey}-${t}`] === driverId) {
        delete state.truckDrivers[`${dayKey}-${t}`];
      }
    }

    state.truckDrivers[truckKey] = driverId;
    const name = driver?.name?.split(' ')[0] || 'Driver';

    if (status && !status.available) {
      showToast(`‚ö† ${name} assigned to Truck ${truck} ‚Äî but ${status.label}`, 'error');
    } else {
      showToast(`${name} ‚Üí Truck ${truck}`, 'success');
    }
  }

  saveTruckDrivers();
  closeDriverPicker();
  renderRightPanel();
  renderMap();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// COMMIT TO TRELLO
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function commitDay() {
  const key = state.activeRightDay;
  const daySchedule = state.schedule[key];
  if (!daySchedule) return;

  const dates = [...getWeekDates(0), ...getWeekDates(1)];
  const dayInfo = dates.find(d => d.key === key);
  if (!dayInfo) return;

  const pendingStops = Object.entries(daySchedule)
    .flatMap(([truck, stops]) => stops.map((s, i) => ({ ...s, truck, stopNum: i+1 })))
    .filter(s => s.pendingCommit);

  if (!pendingStops.length) { showToast('No pending changes to commit', 'info'); return; }

  const commitBtn = document.getElementById('commit-day-btn');
  commitBtn.disabled = true;
  commitBtn.textContent = `Committing ${pendingStops.length} stops...`;

  const failed = [];

  for (const stop of pendingStops) {
    try {
      const dueDate = dueTimestamp(dayInfo.date);

      // Write due date
      await trello(`/cards/${stop.id}`, 'PUT', { due: dueDate });

      // Write OT = true
      await trello(`/cards/${stop.id}/customField/${CUSTOM_FIELDS.OT}/item`, 'PUT', { value: { checked: 'true' } });

      // Post comment
      const firstStopNote = stop.firstStopApproved ? ' ¬∑ ü•á First Stop' : stop.firstStopRevoked ? ' ¬∑ First Stop request noted' : '';
      await trello(`/cards/${stop.id}/actions/comments`, 'POST', {
        text: `üöõ Scheduled: ${dayInfo.day} ¬∑ Truck ${stop.truck} ¬∑ Stop ${stop.stopNum}${firstStopNote}\n_via CF Dispatch_`
      });

      // Mark as committed
      stop.pendingCommit = false;

    } catch (e) {
      failed.push(stop.cardName);
    }
  }

  commitBtn.disabled = false;
  commitBtn.textContent = 'Commit Day to Trello';

  if (failed.length) {
    showToast(`‚ö† ${failed.length} stop(s) failed to commit: ${failed.join(', ')}`, 'error');
  } else {
    showToast(`‚úÖ ${pendingStops.length} stop(s) committed to Trello`, 'success');
  }

  renderRightPanel();
}

async function commitAll() {
  const allDays = [...getWeekDates(0), ...getWeekDates(1)];
  let total = 0;

  for (const { key } of allDays) {
    const daySchedule = state.schedule[key];
    if (!daySchedule) continue;
    const pending = Object.values(daySchedule).flat().filter(s => s.pendingCommit);
    if (pending.length > 0) {
      state.activeRightDay = key;
      await commitDay();
      total += pending.length;
    }
  }

  if (total === 0) showToast('Nothing to commit', 'info');
  const cab = document.getElementById('commit-all-btn');
  if (cab) cab.style.display = 'none';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// DATA LOADING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
async function loadData() {
  setSyncStatus('syncing', 'Syncing...');

  try {
    // Load drivers from hidden board
    await loadDrivers();

    // Load all board lists to find "Requested for Schedule"
    const lists = await trello(`/boards/${BOARD_ID}/lists?fields=id,name`);
    let rfsListId = lists.find(l => l.name.toLowerCase().includes('requested for schedule'))?.id;

    // Auto-create if missing
    if (!rfsListId) {
      const newList = await trello(`/boards/${BOARD_ID}/lists`, 'POST', { name: 'Requested for Schedule', pos: 'top' });
      rfsListId = newList.id;
      showToast('"Requested for Schedule" list created', 'info');
    }

    // Load cards from that list
    const cards = await trello(`/lists/${rfsListId}/cards?customFieldItems=true&attachments=false&fields=id,name,shortLink,desc,due,dueStart,coordinates,address,locationName&pluginData=true&members=true&member_fields=fullName,avatarUrl,username`);

    // Geocode addresses
    const processed = [];
    for (const card of cards) {
      const processed_card = await processCard(card);
      processed.push(processed_card);
    }

    state.queueCards = processed;

    // Remove cards that have been dragged into the schedule (staged or committed)
    const scheduledCardIds = new Set();
    for (const dayKey of Object.keys(state.schedule)) {
      for (const truck of Object.keys(state.schedule[dayKey])) {
        for (const stop of state.schedule[dayKey][truck]) {
          if (stop.cardId) scheduledCardIds.add(stop.cardId);
        }
      }
    }
    state.queueCards = state.queueCards.filter(c => !scheduledCardIds.has(c.id));

    // Load already-scheduled cards (OT = true) for map display
    await loadScheduledCards();

    setSyncStatus('ok', `Synced ¬∑ ${new Date().toLocaleTimeString()}`);
    renderQueue();
    renderRightPanel();
    renderMap();

  } catch (e) {
    setSyncStatus('error', 'Sync failed');
    if (!e.message?.includes('AUTH')) showToast('Failed to load data from Trello', 'error');
  }
}

async function loadDrivers() {
  const cards = await trello(`/lists/${DRIVERS_LIST_ID}/cards?attachments=true&fields=id,name,due,start&limit=50`);
  state.drivers = cards.map((c) => ({
    id: c.id,
    name: c.name,
    photo: c.attachments?.find(a => a.previews?.length)?.previews?.slice(-1)[0]?.url || null,
    unavailableFrom: c.start || null,
    unavailableUntil: c.due || null,
  }));

  // Restore saved driver assignments from localStorage
  try {
    const saved = JSON.parse(localStorage.getItem('cf_dispatch_truck_drivers') || '{}');
    state.truckDrivers = saved;
  } catch { state.truckDrivers = {}; }
}

function saveTruckDrivers() {
  localStorage.setItem('cf_dispatch_truck_drivers', JSON.stringify(state.truckDrivers));
}

function getDriverForTruck(dayKey, truck) {
  const truckKey = `${dayKey}-${truck}`;
  const driverId = state.truckDrivers[truckKey];
  if (!driverId) return null;
  return state.drivers.find(d => d.id === driverId) || null;
}

function renderDriverBar() {
  const chips = document.getElementById('driver-chips');
  if (!chips) return;
  chips.innerHTML = state.drivers.map(d => {
    const status = getDriverStatus(d);
    const imgSrc = `assets/${d.name.split(' ')[0].toLowerCase()}.png`;
    return `<div class="driver-chip ${!status.available ? 'unavailable' : ''}">
      <img class="driver-avatar" src="${imgSrc}" onerror="this.style.background='#2e3850'" alt="${d.name}" />
      <span class="driver-name">${d.name.split(' ')[0]}</span>
      ${status.label ? `<span class="driver-status">${status.label}</span>` : ''}
    </div>`;
  }).join('<span class="driver-bar-sep">¬∑</span>');
}

async function processCard(card) {
  // Extract custom field values
  const fields = card.customFieldItems || [];
  const rsField = fields.find(f => f.idCustomField === CUSTOM_FIELDS.RS);
  const invField = fields.find(f => f.idCustomField === CUSTOM_FIELDS.INV_TOTAL);

  // Get location directly from card fields (Trello stores Google Places coords here)
  let address = card.address || null;
  let coords = null;
  let quadrant = null;

  if (card.coordinates?.latitude && card.coordinates?.longitude) {
    // Google-accurate coords straight from Trello ‚Äî no geocoding needed
    coords = { lat: card.coordinates.latitude, lng: card.coordinates.longitude };
    quadrant = getQuadrant(coords);
  } else if (address) {
    // Fallback: geocode the address text if no coords on card
    coords = await geocode(address);
    if (coords) quadrant = getQuadrant(coords);
  }

  // Parse delivery instructions from card comments (submitted via request form)
  const commentData = parseDeliveryComment(card.desc || '');

  // Card owner (assigned Trello member = salesperson)
  const requester = card.members?.[0] || null;

  return {
    id: card.id,
    name: card.name,
    shortLink: card.shortLink,
    address,
    coords,
    quadrant,
    rsValue: rsField?.value?.text || '',
    invTotal: invField?.value?.number || null,
    customerName: commentData.customerName,
    customerPhone: commentData.customerPhone,
    firstStopRequested: commentData.firstStop,
    stairs: commentData.stairs,
    equipRemoval: commentData.removal,
    whiteGlove: commentData.whiteGlove,
    dropoff: commentData.dropoff,
    deliveryNotes: commentData.notes,
    requesterName: requester?.fullName || null,
    requesterAvatar: requester?.avatarUrl ? (requester.avatarUrl + '/50.png') : null,
    flags: [
      commentData.stairs && 'ü™ú Stairs',
      commentData.whiteGlove && 'ü§ç White Glove',
      commentData.removal && 'üîß Removal',
    ].filter(Boolean),
  };
}

function getQuadrant(coords) {
  const dLat = coords.lat - FRUITLAND.lat;
  const dLng = coords.lng - FRUITLAND.lng;
  const ns = dLat >= 0 ? 'N' : 'S';
  const ew = dLng >= 0 ? 'E' : 'W';
  return Math.abs(dLat) < 0.02 && Math.abs(dLng) < 0.02 ? 'LOCAL' : `${ns}${ew}`;
}

function parseDeliveryComment(text) {
  // Parse structured comment from request.html
  return {
    customerName: text.match(/üë§ Customer: (.+)/)?.[1]?.trim() || null,
    customerPhone: text.match(/üìû Phone: (.+)/)?.[1]?.trim() || null,
    firstStop: text.includes('FIRST STOP REQUESTED'),
    stairs: text.includes('‚òë Stairs'),
    removal: text.includes('‚òë Equipment Removal'),
    whiteGlove: text.includes('‚òë White Glove'),
    dropoff: text.includes('‚òë Drop-off'),
    notes: text.match(/üìù Notes: (.+)/)?.[1]?.trim() || null,
  };
}

async function loadScheduledCards() {
  // Load all SHIPPER lists and find OT=true cards for map
  const lists = await trello(`/boards/${BOARD_ID}/lists?fields=id,name`);
  const shipperLists = lists.filter(l => l.name.startsWith('SHIPPER'));

  for (const list of shipperLists) {
    try {
      const cards = await trello(`/lists/${list.id}/cards?customFieldItems=true&fields=id,name,shortLink,due`);
      for (const card of cards) {
        const otField = card.customFieldItems?.find(f => f.idCustomField === CUSTOM_FIELDS.OT);
        if (otField?.value?.checked === 'true' && card.due) {
          // Add to schedule display
          const dueDate = new Date(card.due);
          const day = DAYS[dueDate.getDay() - 1];
          if (!day) continue;

          const processed = await processCard(card);
          if (!processed.coords) continue;

          // Determine week
          const week1 = getWeekDates(0);
          const week2 = getWeekDates(1);
          const w1Match = week1.find(d => d.date.toDateString() === dueDate.toDateString());
          const w2Match = week2.find(d => d.date.toDateString() === dueDate.toDateString());
          const dayKey = w1Match?.key || w2Match?.key;
          if (!dayKey) continue;

          if (!state.schedule[dayKey]) state.schedule[dayKey] = {};
          if (!state.schedule[dayKey].A) state.schedule[dayKey].A = [];
          state.schedule[dayKey].A.push({ ...processed, pendingCommit: false });
        }
      }
    } catch {}
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UI HELPERS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderDayPills() {
  const container = document.getElementById('map-controls');
  if (!container) return;
  const week1 = getWeekDates(0);
  const week2 = getWeekDates(1);
  const allDays = [...week1, ...week2];
  const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

  let html = `<div class="day-pill ${state.activeDayFilter === 'ALL' ? 'active' : ''}" style="${state.activeDayFilter === 'ALL' ? 'background:#f0c93a;border-color:#f0c93a' : ''}" onclick="setDayFilter('ALL')"><span class="pill-day">ALL</span></div>`;

  allDays.forEach(({ day, date, key }) => {
    const isActive = state.activeDayFilter === key;
    const dayColor = getDayColor(day, key);
    const activeStyle = isActive ? `background:${dayColor};border-color:${dayColor}` : '';
    html += `<div class="day-pill ${isActive ? 'active' : ''}" style="${activeStyle}" onclick="setDayFilter('${key}')">
      <span class="pill-day">${day}</span>
      <span class="pill-date">${date.getDate()} ${months[date.getMonth()]}</span>
    </div>`;
  });
  container.innerHTML = html;
}

function setDayFilter(key) {
  state.activeDayFilter = key;

  // Also update right panel to show the selected day's routes
  if (key !== 'ALL') {
    state.activeRightDay = key;
  } else {
    // ALL selected ‚Äî show today's date (or nearest working day)
    const now = new Date();
    const todayName = ['SUN','MON','TUE','WED','THU','FRI','SAT'][now.getDay()];
    const allDates = [...getWeekDates(0), ...getWeekDates(1)];
    const today = allDates.find(d => {
      const s = d.date;
      return s.getFullYear() === now.getFullYear() && s.getMonth() === now.getMonth() && s.getDate() === now.getDate();
    });
    if (today) {
      state.activeRightDay = today.key;
    }
    // If today isn't in the 10-day window, keep current activeRightDay
  }

  renderDayPills();
  renderRightPanel();
  renderMap();
}

function setWeek(week) {
  state.activeWeek = week;
  document.querySelectorAll('.week-btn').forEach(b => {
    b.classList.toggle('active', parseInt(b.dataset.week) === week);
  });
  renderRightPanel();
}

function setActiveDay(key) {
  state.activeRightDay = key;
  renderRightPanel();
}

function filterQueue() { renderQueue(); }

function setSyncStatus(type, text) {
  const dot = document.getElementById('sync-dot');
  const label = document.getElementById('sync-label');
  label.textContent = text;
  dot.style.background = type === 'ok' ? 'var(--success)' : type === 'error' ? 'var(--danger)' : 'var(--accent)';
}

function showToast(msg, type = 'info') {
  const container = document.getElementById('toast-container');
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  const icons = { success: '‚úÖ', error: '‚ö†Ô∏è', info: '‚ÑπÔ∏è' };
  toast.innerHTML = `<span>${icons[type]||'‚ÑπÔ∏è'}</span><span>${msg}</span>`;
  container.appendChild(toast);
  setTimeout(() => { toast.style.opacity='0'; toast.style.transform='translateX(10px)'; toast.style.transition='all 0.3s'; setTimeout(()=>toast.remove(), 300); }, 4000);
}

function closeModal(id) {
  document.getElementById(id).classList.remove('open');
}

function openSettings() {
  document.getElementById('settings-token').value = TOKEN !== 'TRELLO_TOKEN_PLACEHOLDER' ? TOKEN : '';
  document.getElementById('settings-overlay').classList.add('open');
}

async function saveSettings() {
  const newToken = document.getElementById('settings-token').value.trim();
  if (!newToken) { showToast('Please enter a token', 'error'); return; }

  TOKEN = newToken;
  localStorage.setItem('cf_dispatch_token', TOKEN);

  // Test connection
  try {
    await trello(`/boards/${BOARD_ID}?fields=name`);
    document.getElementById('connection-status-wrap').style.display = 'block';
    document.getElementById('conn-status-icon').textContent = '‚úÖ';
    document.getElementById('conn-status-text').textContent = 'Connected to CF ASANA';
    showToast('Connected successfully', 'success');
    closeModal('settings-overlay');
    loadData();
  } catch {
    document.getElementById('connection-status-wrap').style.display = 'block';
    document.getElementById('conn-status-icon').textContent = '‚ùå';
    document.getElementById('conn-status-text').textContent = 'Connection failed ‚Äî check token';
  }
}

function showConfirm(icon, title, msg, onConfirm) {
  document.getElementById('confirm-icon').textContent = icon;
  document.getElementById('confirm-title').textContent = title;
  document.getElementById('confirm-msg').textContent = msg;
  const okBtn = document.getElementById('confirm-ok-btn');
  okBtn.onclick = () => { closeModal('confirm-dialog'); onConfirm(); };
  document.getElementById('confirm-dialog').classList.add('open');
}

async function refreshData() {
  await loadData();
  showToast('Data refreshed', 'info');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// AUTO SYNC
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
setInterval(loadData, 60000);

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INIT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
document.addEventListener('DOMContentLoaded', () => {
  initMap();

  // Restore lock state from localStorage
  loadLockState();

  // Set default right panel day to next Monday
  const week1 = getWeekDates(0);
  state.activeRightDay = week1[0].key;

  // Render dynamic day pills
  renderDayPills();

  // Load data
  loadData();
});
</script>

<!-- BRAND FLOAT -->
<div class="brand-float">
  <div style="display:flex;flex-direction:column;align-items:flex-start;gap:1px;">
    <img src="assets/dispatch-logo-new.png" class="brand-logo" alt="Dispatch" />
    <span class="brand-byline" style="align-self:flex-end;">by: will.powah</span>
  </div>
</div>

<!-- ACTION BUTTONS -->
<div class="action-float">
  <div class="sync-indicator" style="display:flex;align-items:center;gap:4px;margin-right:4px;">
    <div class="sync-dot" id="sync-dot"></div>
    <span id="sync-label" style="font-size:9px;color:rgba(0,0,0,0.22);font-family:'Inter Tight',sans-serif;white-space:nowrap;">Connecting...</span>
  </div>
  <button class="btn-icon" onclick="refreshData()" title="Refresh">‚Üª</button>
  <button class="btn-icon" onclick="openSettings()" title="Settings">‚öô</button>
</div>

</body>
</html>
